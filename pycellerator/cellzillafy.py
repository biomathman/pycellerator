#
#   cellzillafy.py is draft developmental software
#
# alpha code not ready for use yet
# this code is not required for pycellerator -- it is developmental
# and may be changed or withdrawn. It is not used pycellerator but parts
# of it may be used in the future
#   
#****************************************************************************
#    pycellerator converts reactions, expressed in a text-formatted arrow-based 
#    notation into differential equations and performs numerical simulations.
#
#****************************************************************************
#
#    Copyright (C) 2012-2015
#    
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#****************************************************************************

#
from reader import *
from sys import argv, exit
from os.path import realpath, isfile
import interpreter, expander
import Tissue2D
from math import log, ceil
import re
import sys
import datetime
import time
import utils

def print_rule():
    print 50*"-"

##############################################################################    
def classify_input(parsed_reactions, ncells, nspecie, PRINT=True):
    # summarize input
    #
    classes = {}
    for r in parsed_reactions:
        reaction_class=r.arrowtype+" "+r.arrow
        if reaction_class in classes:
            classes[reaction_class]+=1
        else:
            classes[reaction_class]=1
    expanded_reactions = expander.expand(parsed_reactions)

    class_names=list(classes)
    if PRINT:
        print_rule()
        print "%5d" %(len(parsed_reactions)), "reactions input."
        print "%5d" %(len(expanded_reactions)), " expanded reactions"
        for class_name in class_names:
            print "%5d" %(classes[class_name]), class_name, "reactions"
        print "%5d" %(ncells*nspecie), " differential equations"  
        print_rule()   
    return expanded_reactions
##############################################################################


def make_diffusion_dictionary(parsed_reactions):
    diffusion_dict={}
    for r in parsed_reactions:
        if r.ArrowType() == "Diffusion":
            diffusion_dict[r.lhs[0]]=r.rates[0]
        else:
            continue
    return diffusion_dict
##############################################################################

def make_solution_variable(symbol_dict, old_species_names):
    symbol_names = set(list(symbol_dict)) - set(list(old_species_names))
    var_base="y"
    var = var_base
    
    yy=1
    while (var in symbol_names) or (var+"prime" in symbol_names):
        var = var_base +str(yy)
        yy++1
    return var

##############################################################################

def indexify(x,k,digits=1):
    subscript=str(k)
    while len(subscript)<digits:
            subscript="0"+subscript
    subscript="_"+subscript
    return(str(x)+subscript)
    #
 ##############################################################################
  #
def specify(x):
    return ( "_SPECIES_("+str(x)+")")
##############################################################################
def function_header():
    ver = sys.version.replace("\n"," ")
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    headers = ["def ode_function_rhs(y,t):",
     "    # =============================================================",
     "    # automatically generated by cellzillarator "+ now,
     "    # " + ver,
     "    # " + sys.platform ,
     "    # ============================================================="]
    return headers


##############################################################################

  
##############################################################################

def cellzillafy(modelfile, tissuefile):

    #-------------------------------------------------------------------------
    def Diffusion_Correction(X, diffusion_dict, icell):
        corrections = 0
        if X in diffusion_dict:
            D = symbols(diffusion_dict[X])
            neighbors = T.neighbors_of(icell)
            xhere = symbols(indexify(X,icell, max_digits))
            corrections=0
            for neighbor in neighbors:
                other_cell_number, common_edge_number, ell_over_A=neighbor
                xthere = symbols(indexify(X,other_cell_number, max_digits))
                correction = ell_over_A * D * (xthere - xhere)
                correction = correction.subs({xthere:specify(xthere), xhere:specify(xhere)})
            corrections = corrections + correction
           
        return corrections
    
    #--------------------------------------------------------------------------
    def numberfy_species(n, max_digits, ic, symbol_dict, diffusion_dict, odeterms):

        old_species_names = list(ic)
        old_species = [symbol_dict[X] for X in old_species_names]
        tissufied_ode_terms={}
        for icell in range(n):
        # for each cell in the tissue
        # define names of the subscripted species
        #
            subscripted_species = [indexify(X, icell, max_digits) for X in old_species_names]
            new_species=[symbols(X)  for X in subscripted_species]  
            old_new = zip(old_species, new_species)

            i=0
            for X in old_species_names:
                newterm = odeterms[X]
            
                for (old, new) in old_new:
                    newterm = newterm.subs(old, specify(new))
           
                X_sub_i = subscripted_species[i]
                corrections = Diffusion_Correction(X, diffusion_dict, icell)
                newterm = newterm + corrections
                # index by string instead of symbol
                tissufied_ode_terms[X_sub_i]=newterm
                i += 1
        return tissufied_ode_terms    

   #--------------------------------------------------------------------------
 
    cpu_in_the_beginning = time.clock()
    
    T = Tissue2D.readGeometryFile(tfile)
    n=len(T.cells)
    max_digits = round( ceil(log(n,10))) # digits needed for pretty indices
    print "%5d" %(n),"cells in tissue."
    
    #
    # read the data file
    #
    (raw_reactions, ic, rates, frozenvars, functions,assignments, filename)=readmodel(INFILE=modelfile)
    # 
    #
    # parse the raw_reactions
    #
    classes = {}
    DUMP = ("-DUMP" in argv)
    parsed_reactions = interpreter.invokeParser(raw_reactions, dump=DUMP)
    expanded_reactions=classify_input(parsed_reactions, n, len(ic),  PRINT=True)
    symbol_dict=interpreter.makeSymbolDictionary(expanded_reactions, rates, ic)
    odeterms = interpreter.makeODETerms(expanded_reactions, symbol_dict, frozen=frozenvars)    
    #
    # instantiate rates in output code
    #
    precode=[]
    for rate in sorted(list(rates)):
           precode.append(rate+"="+str(rates[rate]))   
    #  
    unique_solution_variable = make_solution_variable(symbol_dict, list(ic))
    #
    # determine species that have diffusion
    #
    diffusion_dict = make_diffusion_dictionary(parsed_reactions)
    #
    # repeat the reactions on each cell in the tissue
    #
    cpu_2 = time.clock()
    tissufied_ode_terms= numberfy_species(n, max_digits, ic, symbol_dict, diffusion_dict, odeterms)
    cpu_3 = time.clock()

    print "generate code as Species(name(cell)):  ", cpu_3-cpu_2, " seconds."  
    
    #
    # generate replacement rules to number all species 
    #  0 to ncells-1: first species
    #  ncells to 2ncells-1: second species
    #  2ncells to 3ncells-1: third species
    #  ...
    #        
    
    Species_Names = sorted(map(str, list(tissufied_ode_terms)))
    Species_Zip = zip(Species_Names, range(len(Species_Names)))
    Species_Name_to_Number = {name:num for name,num in Species_Zip}

    code = precode
        
    cpu_4=time.clock()
  
    for S in Species_Names:      
        rhs = tissufied_ode_terms[S]
        rhs = str(rhs)
        #
        # 
        # insert string replacement to replace "_SPECIES_(k)" --> y[k] 
        #
        # REGULAR EXPRESSION SYNTAX: ?P<fred>d+ means create a group named "fred"
        #                            the d+ matches to one or more digits
        #                            \g<fred> in the second argument replaces the 
        #                            corresponding match from the first argument
 
        for (vari, index) in Species_Zip:
            fromstring = "_SPECIES_\("+vari+"\)"
            tostring = unique_solution_variable+"["+str(index)+"]"
            rhs = re.sub(fromstring, tostring, rhs)        
        #
        # do the lhs of the equations: (dX/dt) --> yprime[i]
        #
        #lhs = "_SPECIES_PRIME_("+str(S_Replace[S])+")"
        lhs = "_SPECIES_PRIME_("+str(Species_Name_to_Number[S])+")"
        lhs=re.sub("_SPECIES_PRIME_\((?P<fred>\d+)\)", \
               unique_solution_variable+"prime[\g<fred>]", \
               lhs)
                
        code.append(lhs + "=" + rhs )
        #

    cpu_5=time.clock()
    substime = cpu_5-cpu_4
    
  
    print "convert (SPECIES(name(cell)) --> y[i]):", substime, " seconds."
    
   
    code = [4*(" ")+L for L in code]
    headers=function_header()
    code = headers + code + ["    return yprime"]
    
    print "total time to generate all code:       ", time.clock()-cpu_in_the_beginning," seconds."
    
    return (code)
      
if __name__ == "__main__":
    print "************* CELLLZILLAFY: RUNNING IN DEBUG MODE ****************"
    args=argv
    upper_args = [s.upper() for s in args]
    tfile = ""
    mfile = ""
    if "-IN" in upper_args:
         i = upper_args.index("-IN")
         if i< len(args):
            mfile=args[i+1]
            if isfile(mfile):
                print "Model: ", realpath(mfile)
            else:
                exit("the file " + mfile + " does not exist.")
         else:
             print "No model file."
    else:
        print "No Model file."
    if "-TISSUE" in upper_args:
         i = upper_args.index("-TISSUE")
         if i< len(args):
            tfile=args[i+1]
            if isfile(tfile):
                print "Tissue: ", realpath(tfile)

            else:
                exit("the file " + tfile + " does not exist.")
         else:
            print "No Tissue file."
    else:
        print "No Tissue file."   
    code = cellzillafy(mfile, tfile)
    oname = utils.uniqueFileName("multicellsolver.py")
    code = [line+"\n" for line in code]
    f=open(oname,"w")
    f.writelines(code)
    f.close()

