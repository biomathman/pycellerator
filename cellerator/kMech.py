#!/usr/bin/env python
#
# kMech Expander Module for Cellerator
# B.E.Shapiro 25 Apr 2015 rev.
#
#****************************************************************************
#
#    This file is part of Cellerator
#
#    Cellerator converts reactions, expressed in a text-formatted arrow-based 
#    notation into differential equations and performs numerical simulations.
#    Copyright (C) 2012 Bruce E Shapiro.
#    
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>
# 
# **************************************************************************
"""
about kMech:
============
Originally implemented in Mathematica by Chin-Rang Yang.
This file implements the kMech language in Python, but requires that the 
model first be parsed into the Cellerator database.
============

An Enzyme Mechanism Language for the Mathematical Modeling of Metabolic Pathways

Chin-Rang Yang, Bruce E. Shapiro, Eric D. Mjolsness, and G. Wesley Hatfield

Bioinformatics 21(6):774-780 http://bioinformatics.oxfordjournals.org/content/21/6/774.full

We have developed an enzyme mechanism language for the mathematical modeling of metabolic pathways. This language, kMech, is a comprehensive collection of single and multiple substrate enzyme reactions and regulatory mechanisms that extends Cellerator function for the mathematical modeling of enzyme reactions. Each mechanism has been codified to generate a set of elementary reactions that can be translated by Cellerator into ordinary differential equations (ODEs) solvable by Mathematica. We have also developed methods that use common kinetic measurements to estimate physical constants required to solve these ODEs. Because kMech assembles fundamental modular association-dissociation reaction mechanisms to describe complex enzyme mechanisms, the kMech/Cellerator dynamic modeling system is more flexible, and easily extended, than commonly used simulation systems based on Michaelis-Menten kinetic equations. We have initially used this system to model branched chain amino acid biosynthesis in Escherichia coli. Our simulations of metabolic and genetic perturbations predict experimentally observed results.


"""

from utils import *

def getRatesFor(rates, kindofrate):
    r=[]
    for rateset in rates:
        if rateset[0]==kindofrate:
            r=rateset[1:]
            return r
    print "Error: rates for "+kindofrate+" not found in ",rates
    return r


def NC(*x):
    species=[]
    for specie in x:
        if type(specie)==type([]):
            species=species+specie
        else:
            species.append(specie)
    return "_Complex_"+("_".join(specie))+"_"
def NC2(*x):
    return NC(x)


def product(*x):
    result="1"
    for value in x:
        result = result + "*"+value
    result=result.replace("1*","")
    return '"'+result+'"'

#************* Begin AutoGenerated Stubs 

def handle_UniUni_CI_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S] <=> [P], En, Enz[UniUni[kf, kr, k], CI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S <-> NC[S, En],rates[kf, kr]],
    # [NC[S, En] -> En + P,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'UniUni')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    expansion=[\
        revreacs([En,S],NC(S,En),[kf,kr]),\
        reac(NC(S,En),[En,P],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri])\
    ]
    return expansion

def handle_UniUni_NCI_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S] <=> [P], En, Enz[UniUni[kf, kr, k], NCI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S <-> NC[S, En],rates[kf, kr]],
    # [NC[S, En] -> En + P,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]],
    # [Inh + NC[S, En] <-> NC[S, En, Inh],rates[kfi, kri]],
    # [S + NC[En, Inh] <-> NC[S, En, Inh],rates[kf, kr]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'UniUni')
    [Inh,kfi,kri] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S],NC(S,En),[kf,kr]),\
        reac(NC(S,En),[En,P],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri]),\
        revreacs([Inh,NC(S,En)],NC(S,En,Inh),[kfi,kri]),\
        revreacs([S,NC(En,Inh)],NC(S,En,Inh),[kf,kr])\
    ]
    return expansion

def handle_UniUni_NCI_3_4(r):
    #
    # kMech expander for reaction:
    #  [ [S] <=> [P], En, Enz[UniUni[kf, kr, k], NCI[Inh, kfi, kri, residualRate]] ]
    #
    # The expanded reaction template is:
    # [En + S <-> NC[S, En],rates[kf, kr]],
    # [NC[S, En] -> En + P,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]],
    # [Inh + NC[S, En] <-> NC[S, En, Inh],rates[kfi, kri]],
    # [S + NC[En, Inh] <-> NC[S, En, Inh],rates[kf, kr]],
    # [NC[S, En, Inh] -> P + NC[En, Inh],product[k, residualRate]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'UniUni')
    [Inh,kfi,kri,residualRate] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S],NC(S,En),[kf,kr]),\
        reac(NC(S,En),[En,P],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri]),\
        revreacs([Inh,NC(S,En)],NC(S,En,Inh),[kfi,kri]),\
        revreacs([S,NC(En,Inh)],NC(S,En,Inh),[kf,kr]),\
        reac(NC(S,En,Inh),[P,NC(En,Inh)],product(k,residualRate))\
    ]
    return expansion

def handle_UniUni_UCI_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S] <=> [P], En, Enz[UniUni[kf, kr, k], UCI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S <-> NC[S, En],rates[kf, kr]],
    # [NC[S, En] -> En + P,k],
    # [Inh + NC[S, En] <-> NC[S, En, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'UniUni')
    [Inh,kfi,kri] = getRatesFor(rates,'UCI')
    expansion=[\
        revreacs([En,S],NC(S,En),[kf,kr]),\
        reac(NC(S,En),[En,P],k),\
        revreacs([Inh,NC(S,En)],NC(S,En,Inh),[kfi,kri])\
    ]
    return expansion

def handle_UniUni_3(r):
    #
    # kMech expander for reaction:
    #  [ [S] <=> [P], En, Enz[UniUni[kf, kr, k]] ]
    #
    # The expanded reaction template is:
    # [En + S <-> NC[S, En],rates[kf, kr]],
    # [NC[S, En] -> En + P,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'UniUni')
    expansion=[\
        revreacs([En,S],NC(S,En),[kf,kr]),\
        reac(NC(S,En),[En,P],k)\
    ]
    return expansion

def handle_BiUni_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1], En, Enz[BiUni[kf, kr, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 <-> NC[En, S1, S2],rates[kf, kr]],
    # [NC[En, S1, S2] -> En + P1,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'BiUni')
    expansion=[\
        revreacs([En,S1,S2],NC(En,S1,S2),[kf,kr]),\
        reac(NC(En,S1,S2),[En,P1],k)\
    ]
    return expansion

def handle_OrderedBiUni_5(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1], En, Enz[OrderedBiUni[kf1, kr1, kf2, kr2, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [NC[En, S1, S2] -> En + P1,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'OrderedBiUni')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        reac(NC(En,S1,S2),[En,P1],k)\
    ]
    return expansion

def handle_UniBi_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1] <=> [P1, P2], En, Enz[UniBi[kf, kr, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf, kr]],
    # [NC[En, S1] -> En + P1 + P2,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'UniBi')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf,kr]),\
        reac(NC(En,S1),[En,P1,P2],k)\
    ]
    return expansion

def handle_BiUni_CI_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1], En, Enz[BiUni[kf, kr, k], CI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 <-> NC[En, S1, S2],rates[kf, kr]],
    # [NC[En, S1, S2] -> En + P1,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'BiUni')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    expansion=[\
        revreacs([En,S1,S2],NC(En,S1,S2),[kf,kr]),\
        reac(NC(En,S1,S2),[En,P1],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri])\
    ]
    return expansion

def handle_UniBi_CI_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1] <=> [P1, P2], En, Enz[UniBi[kf, kr, k], CI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf, kr]],
    # [NC[En, S1] -> En + P1 + P2,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'UniBi')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf,kr]),\
        reac(NC(En,S1),[En,P1,P2],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri])\
    ]
    return expansion

def handle_UniBi_CI_NCI_3_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1] <=> [P1, P2], En, Enz[UniBi[kf, kr, k], CI[Inh, kfi, kri], NCI[Inhn, kfin, krin]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf, kr]],
    # [NC[En, S1] -> En + P1 + P2,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]],
    # [En + Inhn <-> NC[En, Inhn],rates[kfin, krin]],
    # [Inhn + NC[En, S1] <-> NC[En, S1, Inhn],rates[kfin, krin]],
    # [S1 + NC[En, Inhn] <-> NC[En, S1, Inhn],rates[kf, kr]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'UniBi')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    [Inhn,kfin,krin] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf,kr]),\
        reac(NC(En,S1),[En,P1,P2],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri]),\
        revreacs([En,Inhn],NC(En,Inhn),[kfin,krin]),\
        revreacs([Inhn,NC(En,S1)],NC(En,S1,Inhn),[kfin,krin]),\
        revreacs([S1,NC(En,Inhn)],NC(En,S1,Inhn),[kf,kr])\
    ]
    return expansion

def handle_BiUni_CI_NCI_3_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1], En, Enz[BiUni[kf, kr, k], CI[Inh, kfi, kri], NCI[Inhn, kfin, krin]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 <-> NC[En, S1, S2],rates[kf, kr]],
    # [NC[En, S1, S2] -> En + P1,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]],
    # [En + Inhn <-> NC[En, Inhn],rates[kfin, krin]],
    # [Inhn + NC[En, S1, S2] <-> NC[En, S1, S2, Inhn],rates[kfin, krin]],
    # [S1 + S2 + NC[En, Inhn] <-> NC[En, S1, S2, Inhn],rates[kf, kr]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'BiUni')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    [Inhn,kfin,krin] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S1,S2],NC(En,S1,S2),[kf,kr]),\
        reac(NC(En,S1,S2),[En,P1],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri]),\
        revreacs([En,Inhn],NC(En,Inhn),[kfin,krin]),\
        revreacs([Inhn,NC(En,S1,S2)],NC(En,S1,S2,Inhn),[kfin,krin]),\
        revreacs([S1,S2,NC(En,Inhn)],NC(En,S1,S2,Inhn),[kf,kr])\
    ]
    return expansion

def handle_BiBi_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[BiBi[kf, kr, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 <-> NC[En, S1, S2],rates[kf, kr]],
    # [NC[En, S1, S2] -> En + P1 + P2,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'BiBi')
    expansion=[\
        revreacs([En,S1,S2],NC(En,S1,S2),[kf,kr]),\
        reac(NC(En,S1,S2),[En,P1,P2],k)\
    ]
    return expansion

def handle_OrderedBiBi_5(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[OrderedBiBi[kf1, kr1, kf2, kr2, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [NC[En, S1, S2] -> P1 + NC[En, S2],k],
    # [NC[En, S2] -> En + P2,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'OrderedBiBi')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        reac(NC(En,S1,S2),[P1,NC(En,S2)],k),\
        reac(NC(En,S2),[En,P2],k)\
    ]
    return expansion

def handle_OrderedBiBi_CI_5_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[OrderedBiBi[kf1, kr1, kf2, kr2, k], CI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [NC[En, S1, S2] -> P1 + NC[En, S2],k],
    # [NC[En, S2] -> En + P2,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'OrderedBiBi')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        reac(NC(En,S1,S2),[P1,NC(En,S2)],k),\
        reac(NC(En,S2),[En,P2],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri])\
    ]
    return expansion

def handle_OrderedBiBi_CI1_CI2_5_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[OrderedBiBi[kf1, kr1, kf2, kr2, k], CI1[Inh1, kfi1, kri1], CI2[Inh2, kfi2, kri2]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [NC[En, S1, S2] -> P1 + NC[En, S2],k],
    # [NC[En, S2] -> En + P2,k],
    # [En + Inh1 <-> NC[En, Inh1],rates[kfi1, kri1]],
    # [En + Inh2 <-> NC[En, Inh2],rates[kfi1, kri2]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'OrderedBiBi')
    [Inh1,kfi1,kri1] = getRatesFor(rates,'CI1')
    [Inh2,kfi2,kri2] = getRatesFor(rates,'CI2')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        reac(NC(En,S1,S2),[P1,NC(En,S2)],k),\
        reac(NC(En,S2),[En,P2],k),\
        revreacs([En,Inh1],NC(En,Inh1),[kfi1,kri1]),\
        revreacs([En,Inh2],NC(En,Inh2),[kfi1,kri2])\
    ]
    return expansion

def handle_RandomBiBi_5(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[RandomBiBi[kf1, kr1, kf2, kr2, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [En + S2 <-> NC[En, S2],rates[kf2, kr2]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [S1 + NC[En, S2] <-> NC[En, S1, S2],rates[kf1, kr1]],
    # [NC[En, S1, S2] -> En + P1 + P2,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'RandomBiBi')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([En,S2],NC(En,S2),[kf2,kr2]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        revreacs([S1,NC(En,S2)],NC(En,S1,S2),[kf1,kr1]),\
        reac(NC(En,S1,S2),[En,P1,P2],k)\
    ]
    return expansion

def handle_RandomBiBi_CI_5_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[RandomBiBi[kf1, kr1, kf2, kr2, k], CI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [En + S2 <-> NC[En, S2],rates[kf2, kr2]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [S1 + NC[En, S2] <-> NC[En, S1, S2],rates[kf1, kr1]],
    # [NC[En, S1, S2] -> En + P1 + P2,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'RandomBiBi')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([En,S2],NC(En,S2),[kf2,kr2]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        revreacs([S1,NC(En,S2)],NC(En,S1,S2),[kf1,kr1]),\
        reac(NC(En,S1,S2),[En,P1,P2],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri])\
    ]
    return expansion

def handle_RandomBiBi_CI1_CI2_5_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[RandomBiBi[kf1, kr1, kf2, kr2, k], CI1[Inh1, kfi1, kri1], CI2[Inh2, kfi2, kri2]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [En + S2 <-> NC[En, S2],rates[kf2, kr2]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [S1 + NC[En, S2] <-> NC[En, S1, S2],rates[kf1, kr1]],
    # [NC[En, S1, S2] -> En + P1 + P2,k],
    # [En + Inh1 <-> NC[En, Inh1],rates[kfi1, kri1]],
    # [En + Inh2 <-> NC[En, Inh2],rates[kfi1, kri2]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'RandomBiBi')
    [Inh1,kfi1,kri1] = getRatesFor(rates,'CI1')
    [Inh2,kfi2,kri2] = getRatesFor(rates,'CI2')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([En,S2],NC(En,S2),[kf2,kr2]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        revreacs([S1,NC(En,S2)],NC(En,S1,S2),[kf1,kr1]),\
        reac(NC(En,S1,S2),[En,P1,P2],k),\
        revreacs([En,Inh1],NC(En,Inh1),[kfi1,kri1]),\
        revreacs([En,Inh2],NC(En,Inh2),[kfi1,kri2])\
    ]
    return expansion

def handle_RandomBiBi_NCI_5_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[RandomBiBi[kf1, kr1, kf2, kr2, k], NCI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [En + S2 <-> NC[En, S2],rates[kf2, kr2]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [S1 + NC[En, S2] <-> NC[En, S1, S2],rates[kf1, kr1]],
    # [NC[En, S1, S2] -> En + P1 + P2,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]],
    # [Inh + NC[En, S1] <-> NC[En, S1, Inh],rates[kfi, kri]],
    # [Inh + NC[En, S2] <-> NC[En, S2, Inh],rates[kfi, kri]],
    # [Inh + NC[En, S1, S2] <-> NC[En, S1, S2, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'RandomBiBi')
    [Inh,kfi,kri] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([En,S2],NC(En,S2),[kf2,kr2]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        revreacs([S1,NC(En,S2)],NC(En,S1,S2),[kf1,kr1]),\
        reac(NC(En,S1,S2),[En,P1,P2],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri]),\
        revreacs([Inh,NC(En,S1)],NC(En,S1,Inh),[kfi,kri]),\
        revreacs([Inh,NC(En,S2)],NC(En,S2,Inh),[kfi,kri]),\
        revreacs([Inh,NC(En,S1,S2)],NC(En,S1,S2,Inh),[kfi,kri])\
    ]
    return expansion

def handle_RandomBiBi_NCI1_NCI2_5_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[RandomBiBi[kf1, kr1, kf2, kr2, k], NCI1[Inh1, kfi1, kri1], NCI2[Inh2, kfi2, kri2]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[En, S1],rates[kf1, kr1]],
    # [En + S2 <-> NC[En, S2],rates[kf2, kr2]],
    # [S2 + NC[En, S1] <-> NC[En, S1, S2],rates[kf2, kr2]],
    # [S1 + NC[En, S2] <-> NC[En, S1, S2],rates[kf1, kr1]],
    # [NC[En, S1, S2] -> En + P1 + P2,k],
    # [En + Inh1 <-> NC[En, Inh1],rates[kfi1, kri1]],
    # [Inh1 + NC[En, S1] <-> NC[En, S1, Inh1],rates[kfi1, kri1]],
    # [Inh1 + NC[En, S2] <-> NC[En, S2, Inh1],rates[kfi1, kri1]],
    # [Inh1 + NC[En, S1, S2] <-> NC[En, S1, S2, Inh1],rates[kfi1, kri1]],
    # [En + Inh2 <-> NC[En, Inh2],rates[kfi2, kri2]],
    # [Inh2 + NC[En, S1] <-> NC[En, S1, Inh2],rates[kfi2, kri2]],
    # [Inh2 + NC[En, S2] <-> NC[En, S2, Inh2],rates[kfi2, kri2]],
    # [Inh2 + NC[En, S1, S2] <-> NC[En, S1, S2, Inh2],rates[kfi2, kri2]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,kf2,kr2,k] = getRatesFor(rates,'RandomBiBi')
    [Inh1,kfi1,kri1] = getRatesFor(rates,'NCI1')
    [Inh2,kfi2,kri2] = getRatesFor(rates,'NCI2')
    expansion=[\
        revreacs([En,S1],NC(En,S1),[kf1,kr1]),\
        revreacs([En,S2],NC(En,S2),[kf2,kr2]),\
        revreacs([S2,NC(En,S1)],NC(En,S1,S2),[kf2,kr2]),\
        revreacs([S1,NC(En,S2)],NC(En,S1,S2),[kf1,kr1]),\
        reac(NC(En,S1,S2),[En,P1,P2],k),\
        revreacs([En,Inh1],NC(En,Inh1),[kfi1,kri1]),\
        revreacs([Inh1,NC(En,S1)],NC(En,S1,Inh1),[kfi1,kri1]),\
        revreacs([Inh1,NC(En,S2)],NC(En,S2,Inh1),[kfi1,kri1]),\
        revreacs([Inh1,NC(En,S1,S2)],NC(En,S1,S2,Inh1),[kfi1,kri1]),\
        revreacs([En,Inh2],NC(En,Inh2),[kfi2,kri2]),\
        revreacs([Inh2,NC(En,S1)],NC(En,S1,Inh2),[kfi2,kri2]),\
        revreacs([Inh2,NC(En,S2)],NC(En,S2,Inh2),[kfi2,kri2]),\
        revreacs([Inh2,NC(En,S1,S2)],NC(En,S1,S2,Inh2),[kfi2,kri2])\
    ]
    return expansion

def handle_BiBi_CI_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], En, Enz[BiBi[kf, kr, k], CI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 <-> NC[En, S1, S2],rates[kf, kr]],
    # [NC[En, S1, S2] -> En + P1 + P2,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'BiBi')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    expansion=[\
        revreacs([En,S1,S2],NC(En,S1,S2),[kf,kr]),\
        reac(NC(En,S1,S2),[En,P1,P2],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri])\
    ]
    return expansion

def handle_MulS_3(r):
    #
    # kMech expander for reaction:
    #  [ [S] <=> [P], En, Enz[MulS[kf, kr, k]] ]
    #
    # The expanded reaction template is:
    # [En + S <-> NC[En, S],rates[kf, kr]],
    # [NC[En, S] -> En + P,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'MulS')
    expansion=[\
        revreacs([En,S],NC(En,S),[kf,kr]),\
        reac(NC(En,S),[En,P],k)\
    ]
    return expansion

def handle_BiTer_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2, P3], En, Enz[BiTer[kf, kr, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 <-> NC[En, S1, S2],rates[kf, kr]],
    # [NC[En, S1, S2] -> En + P1 + P2 + P3,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'BiTer')
    expansion=[\
        revreacs([En,S1,S2],NC(En,S1,S2),[kf,kr]),\
        reac(NC(En,S1,S2),[En,P1,P2,P3],k)\
    ]
    return expansion

def handle_TerBi_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2, S3] <=> [P1, P2], En, Enz[TerBi[kf, kr, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 + S3 <-> NC[En, S1, S2, S3],rates[kf, kr]],
    # [NC[En, S1, S2, S3] -> En + P1 + P2,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'TerBi')
    expansion=[\
        revreacs([En,S1,S2,S3],NC(En,S1,S2,S3),[kf,kr]),\
        reac(NC(En,S1,S2,S3),[En,P1,P2],k)\
    ]
    return expansion

def handle_TerTer_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2, S3] <=> [P1, P2, P3], En, Enz[TerTer[kf, kr, k]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 + S3 <-> NC[En, S1, S2, S3],rates[kf, kr]],
    # [NC[En, S1, S2, S3] -> En + P1 + P2 + P3,k]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'TerTer')
    expansion=[\
        revreacs([En,S1,S2,S3],NC(En,S1,S2,S3),[kf,kr]),\
        reac(NC(En,S1,S2,S3),[En,P1,P2,P3],k)\
    ]
    return expansion

def handle_TerTer_CI_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2, S3] <=> [P1, P2, P3], En, Enz[TerTer[kf, kr, k], CI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 + S3 <-> NC[En, S1, S2, S3],rates[kf, kr]],
    # [NC[En, S1, S2, S3] -> En + P1 + P2 + P3,k],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf,kr,k] = getRatesFor(rates,'TerTer')
    [Inh,kfi,kri] = getRatesFor(rates,'CI')
    expansion=[\
        revreacs([En,S1,S2,S3],NC(En,S1,S2,S3),[kf,kr]),\
        reac(NC(En,S1,S2,S3),[En,P1,P2,P3],k),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri])\
    ]
    return expansion

def handle_PingPong_6(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], Mod[En, Enx], Enz[PingPong[kf1, kr1, k1, kf2, kr2, k2]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[S1, En],rates[kf1, kr1]],
    # [NC[S1, En] -> Enx + P1,k1],
    # [Enx + S2 <-> NC[S2, Enx],rates[kf2, kr2]],
    # [NC[S2, Enx] -> En + P2,k2]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2] = getRatesFor(rates,'PingPong')
    expansion=[\
        revreacs([En,S1],NC(S1,En),[kf1,kr1]),\
        reac(NC(S1,En),[Enx,P1],k1),\
        revreacs([Enx,S2],NC(S2,Enx),[kf2,kr2]),\
        reac(NC(S2,Enx),[En,P2],k2)\
    ]
    return expansion

def handle_PingPong_NCI_6_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], Mod[En, Enx], Enz[PingPong[kf1, kr1, k1, kf2, kr2, k2], NCI[Inh, kfi, kri]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[S1, En],rates[kf1, kr1]],
    # [NC[S1, En] -> Enx + P1,k1],
    # [Enx + S2 <-> NC[S2, Enx],rates[kf2, kr2]],
    # [NC[S2, Enx] -> En + P2,k2],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]],
    # [Inh + NC[S1, En] <-> NC[S1, En, Inh],rates[kfi, kri]],
    # [Enx + Inh <-> NC[Enx, Inh],rates[kfi, kri]],
    # [Inh + NC[S2, Enx] <-> NC[S2, Enx, Inh],rates[kfi, kri]],
    # [S1 + NC[En, Inh] <-> NC[S1, En, Inh],rates[kf1, kr1]],
    # [S2 + NC[Enx, Inh] <-> NC[S2, Enx, Inh],rates[kf2, kr2]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2] = getRatesFor(rates,'PingPong')
    [Inh,kfi,kri] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S1],NC(S1,En),[kf1,kr1]),\
        reac(NC(S1,En),[Enx,P1],k1),\
        revreacs([Enx,S2],NC(S2,Enx),[kf2,kr2]),\
        reac(NC(S2,Enx),[En,P2],k2),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri]),\
        revreacs([Inh,NC(S1,En)],NC(S1,En,Inh),[kfi,kri]),\
        revreacs([Enx,Inh],NC(Enx,Inh),[kfi,kri]),\
        revreacs([Inh,NC(S2,Enx)],NC(S2,Enx,Inh),[kfi,kri]),\
        revreacs([S1,NC(En,Inh)],NC(S1,En,Inh),[kf1,kr1]),\
        revreacs([S2,NC(Enx,Inh)],NC(S2,Enx,Inh),[kf2,kr2])\
    ]
    return expansion

def handle_PingPong_NCI_6_4(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], Mod[En, Enx], Enz[PingPong[kf1, kr1, k1, kf2, kr2, k2], NCI[Inh, kfi, kri, residualRate]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[S1, En],rates[kf1, kr1]],
    # [NC[S1, En] -> Enx + P1,k1],
    # [Enx + S2 <-> NC[S2, Enx],rates[kf2, kr2]],
    # [NC[S2, Enx] -> En + P2,k2],
    # [S1 + NC[En, Inh] <-> NC[S1, En, Inh],rates[kf1, kr1]],
    # [NC[S1, En, Inh] -> P1 + NC[En, Inh],product[k1, residualRate]],
    # [S2 + NC[Enx, Inh] <-> NC[S2, Enx, Inh],rates[kf2, kr2]],
    # [NC[S2, Enx, Inh] -> P2 + NC[Enx, Inh],product[k2, residualRate]],
    # [En + Inh <-> NC[En, Inh],rates[kfi, kri]],
    # [Inh + NC[S1, En] <-> NC[S1, En, Inh],rates[kfi, kri]],
    # [Enx + Inh <-> NC[Enx, Inh],rates[kfi, kri]],
    # [Inh + NC[S2, Enx] <-> NC[S2, Enx, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2] = getRatesFor(rates,'PingPong')
    [Inh,kfi,kri,residualRate] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S1],NC(S1,En),[kf1,kr1]),\
        reac(NC(S1,En),[Enx,P1],k1),\
        revreacs([Enx,S2],NC(S2,Enx),[kf2,kr2]),\
        reac(NC(S2,Enx),[En,P2],k2),\
        revreacs([S1,NC(En,Inh)],NC(S1,En,Inh),[kf1,kr1]),\
        reac(NC(S1,En,Inh),[P1,NC(En,Inh)],product(k1,residualRate)),\
        revreacs([S2,NC(Enx,Inh)],NC(S2,Enx,Inh),[kf2,kr2]),\
        reac(NC(S2,Enx,Inh),[P2,NC(Enx,Inh)],product(k2,residualRate)),\
        revreacs([En,Inh],NC(En,Inh),[kfi,kri]),\
        revreacs([Inh,NC(S1,En)],NC(S1,En,Inh),[kfi,kri]),\
        revreacs([Enx,Inh],NC(Enx,Inh),[kfi,kri]),\
        revreacs([Inh,NC(S2,Enx)],NC(S2,Enx,Inh),[kfi,kri])\
    ]
    return expansion

def handle_PingPong_NCI_6_6(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], Mod[En, Enx], Enz[PingPong[kf1, kr1, k1, kf2, kr2, k2], NCI[Inh, kfi1, kri1, kfi2, kri2, residualRate]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[S1, En],rates[kf1, kr1]],
    # [NC[S1, En] -> Enx + P1,k1],
    # [Enx + S2 <-> NC[S2, Enx],rates[kf2, kr2]],
    # [NC[S2, Enx] -> En + P2,k2],
    # [S1 + NC[En, Inh] <-> NC[S1, En, Inh],rates[kf1, kr1]],
    # [NC[S1, En, Inh] -> P1 + NC[En, Inh],product[k1, residualRate]],
    # [S2 + NC[Enx, Inh] <-> NC[S2, Enx, Inh],rates[kf2, kr2]],
    # [NC[S2, Enx, Inh] -> P2 + NC[Enx, Inh],product[k2, residualRate]],
    # [En + Inh <-> NC[En, Inh],rates[kfi1, kri1]],
    # [Inh + NC[S1, En] <-> NC[S1, En, Inh],rates[kfi1, kri1]],
    # [Enx + Inh <-> NC[Enx, Inh],rates[kfi2, kri2]],
    # [Inh + NC[S2, Enx] <-> NC[S2, Enx, Inh],rates[kfi2, kri2]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2] = getRatesFor(rates,'PingPong')
    [Inh,kfi1,kri1,kfi2,kri2,residualRate] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S1],NC(S1,En),[kf1,kr1]),\
        reac(NC(S1,En),[Enx,P1],k1),\
        revreacs([Enx,S2],NC(S2,Enx),[kf2,kr2]),\
        reac(NC(S2,Enx),[En,P2],k2),\
        revreacs([S1,NC(En,Inh)],NC(S1,En,Inh),[kf1,kr1]),\
        reac(NC(S1,En,Inh),[P1,NC(En,Inh)],product(k1,residualRate)),\
        revreacs([S2,NC(Enx,Inh)],NC(S2,Enx,Inh),[kf2,kr2]),\
        reac(NC(S2,Enx,Inh),[P2,NC(Enx,Inh)],product(k2,residualRate)),\
        revreacs([En,Inh],NC(En,Inh),[kfi1,kri1]),\
        revreacs([Inh,NC(S1,En)],NC(S1,En,Inh),[kfi1,kri1]),\
        revreacs([Enx,Inh],NC(Enx,Inh),[kfi2,kri2]),\
        revreacs([Inh,NC(S2,Enx)],NC(S2,Enx,Inh),[kfi2,kri2])\
    ]
    return expansion

def handle_PingPong_NCI2_6_4(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], Mod[En, Enx], Enz[PingPong[kf1, kr1, k1, kf2, kr2, k2], NCI2[Inh, kfi, kri, residualRate]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[S1, En],rates[kf1, kr1]],
    # [NC[S1, En] -> Enx + P1,k1],
    # [Enx + S2 <-> NC[S2, Enx],rates[kf2, kr2]],
    # [NC[S2, Enx] -> En + P2,k2],
    # [S1 + NC[En, Inh] <-> NC[S1, En, Inh],rates[kf1, kr1]],
    # [NC[S1, En, Inh] -> P1 + NC[En, Inh],product[k1, residualRate]],
    # [S2 + NC[Enx, Inh] <-> NC[S2, Enx, Inh],rates[kf2, kr2]],
    # [NC[S2, Enx, Inh] -> P2 + NC[Enx, Inh],product[k2, residualRate]],
    # [Enx + Inh <-> NC[Enx, Inh],rates[kfi, kri]],
    # [Inh + NC[S2, Enx] <-> NC[S2, Enx, Inh],rates[kfi, kri]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2] = getRatesFor(rates,'PingPong')
    [Inh,kfi,kri,residualRate] = getRatesFor(rates,'NCI2')
    expansion=[\
        revreacs([En,S1],NC(S1,En),[kf1,kr1]),\
        reac(NC(S1,En),[Enx,P1],k1),\
        revreacs([Enx,S2],NC(S2,Enx),[kf2,kr2]),\
        reac(NC(S2,Enx),[En,P2],k2),\
        revreacs([S1,NC(En,Inh)],NC(S1,En,Inh),[kf1,kr1]),\
        reac(NC(S1,En,Inh),[P1,NC(En,Inh)],product(k1,residualRate)),\
        revreacs([S2,NC(Enx,Inh)],NC(S2,Enx,Inh),[kf2,kr2]),\
        reac(NC(S2,Enx,Inh),[P2,NC(Enx,Inh)],product(k2,residualRate)),\
        revreacs([Enx,Inh],NC(Enx,Inh),[kfi,kri]),\
        revreacs([Inh,NC(S2,Enx)],NC(S2,Enx,Inh),[kfi,kri])\
    ]
    return expansion

def handle_PingPong_CI_NCI_6_3_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], Mod[En, Enx], Enz[PingPong[kf1, kr1, k1, kf2, kr2, k2], CI[Inh1, kfi1, kri1], NCI[Inh2, kfi2, kri2]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[S1, En],rates[kf1, kr1]],
    # [NC[S1, En] -> Enx + P1,k1],
    # [En + Inh1 <-> NC[En, Inh1],rates[kfi1, kri1]],
    # [Enx + S2 <-> NC[S2, Enx],rates[kf2, kr2]],
    # [NC[S2, Enx] -> En + P2,k2],
    # [Enx + Inh2 <-> NC[Enx, Inh2],rates[kfi2, kri2]],
    # [Inh2 + NC[S2, Enx] <-> NC[S2, Enx, Inh2],rates[kfi2, kri2]],
    # [S2 + NC[Enx, Inh2] <-> NC[S2, Enx, Inh2],rates[kf2, kr2]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2] = getRatesFor(rates,'PingPong')
    [Inh1,kfi1,kri1] = getRatesFor(rates,'CI')
    [Inh2,kfi2,kri2] = getRatesFor(rates,'NCI')
    expansion=[\
        revreacs([En,S1],NC(S1,En),[kf1,kr1]),\
        reac(NC(S1,En),[Enx,P1],k1),\
        revreacs([En,Inh1],NC(En,Inh1),[kfi1,kri1]),\
        revreacs([Enx,S2],NC(S2,Enx),[kf2,kr2]),\
        reac(NC(S2,Enx),[En,P2],k2),\
        revreacs([Enx,Inh2],NC(Enx,Inh2),[kfi2,kri2]),\
        revreacs([Inh2,NC(S2,Enx)],NC(S2,Enx,Inh2),[kfi2,kri2]),\
        revreacs([S2,NC(Enx,Inh2)],NC(S2,Enx,Inh2),[kf2,kr2])\
    ]
    return expansion

def handle_PingPongTerTerF_9(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2, S3] <=> [P1, P2, P3], Mod[En, Enx, Eny], Enz[PingPongTerTerF[kf1, kr1, k1, kf2, kr2, k2, kf3, kr3, k3]] ]
    #
    # The expanded reaction template is:
    # [En + S1 + S2 <-> NC[S1, S2, En],rates[kf1, kr1]],
    # [NC[S1, S2, En] -> Enx + P1,k1],
    # [Enx <-> NC[Eny, P2],rates[kf2, kr2]],
    # [NC[Eny, P2] -> Eny + P2,k2],
    # [Eny + S3 <-> NC[S3, Eny],rates[kf3, kr3]],
    # [NC[S3, Eny] -> En + P3,k3]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx,Eny] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2,kf3,kr3,k3] = getRatesFor(rates,'PingPongTerTerF')
    expansion=[\
        revreacs([En,S1,S2],NC(S1,S2,En),[kf1,kr1]),\
        reac(NC(S1,S2,En),[Enx,P1],k1),\
        revreacs(Enx,NC(Eny,P2),[kf2,kr2]),\
        reac(NC(Eny,P2),[Eny,P2],k2),\
        revreacs([Eny,S3],NC(S3,Eny),[kf3,kr3]),\
        reac(NC(S3,Eny),[En,P3],k3)\
    ]
    return expansion

def handle_PingPongTerTerR_9(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2, S3] <=> [P1, P2, P3], Mod[En, Enx, Eny], Enz[PingPongTerTerR[kf1, kr1, k1, kf2, kr2, k2, kf3, kr3, k3]] ]
    #
    # The expanded reaction template is:
    # [En + S1 <-> NC[S1, En],rates[kf1, kr1]],
    # [NC[S1, En] -> Enx + P1,k1],
    # [Enx + S2 <-> NC[Enx, S2],rates[kf2, kr2]],
    # [NC[Enx, S2] -> Eny,k2],
    # [Eny + S3 <-> NC[S3, Eny],rates[kf3, kr3]],
    # [NC[S3, Eny] -> En + P2 + P3,k3]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx,Eny] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2,kf3,kr3,k3] = getRatesFor(rates,'PingPongTerTerR')
    expansion=[\
        revreacs([En,S1],NC(S1,En),[kf1,kr1]),\
        reac(NC(S1,En),[Enx,P1],k1),\
        revreacs([Enx,S2],NC(Enx,S2),[kf2,kr2]),\
        reac(NC(Enx,S2),Eny,k2),\
        revreacs([Eny,S3],NC(S3,Eny),[kf3,kr3]),\
        reac(NC(S3,Eny),[En,P2,P3],k3)\
    ]
    return expansion

def handle_PingPong_NCmI_6_3(r):
    #
    # kMech expander for reaction:
    #  [ [S1, S2] <=> [P1, P2], Mod[En, Enx], Enz[PingPong[kf1, kr1, k1, kf2, kr2, k2], NCmI[{Inh1, kfiInh1, kriInh1}, {Inh2, kfiInh2, kriInh2}, {Inh3, kfiInh3, kriInh3}]] ]
    #
    # The expanded reaction template is:
    # [NC2[S1, En[0, 0, 0]] -> P1 + Enx[0, 0, 0],k1],
    # [NC2[S2, Enx[0, 0, 0]] -> P2 + En[0, 0, 0],k2],
    # [Inh1 + En[0, 0, 0] <-> En[1, 0, 0],rates[kfiInh1, kriInh1]],
    # [Inh2 + En[0, 0, 0] <-> En[0, 1, 0],rates[kfiInh2, kriInh2]],
    # [Inh3 + En[0, 0, 0] <-> En[0, 0, 1],rates[kfiInh3, kriInh3]],
    # [S1 + En[0, 0, 0] <-> NC2[S1, En[0, 0, 0]],rates[kf1, kr1]],
    # [Inh1 + En[0, 0, 1] <-> En[1, 0, 1],rates[kfiInh1, kriInh1]],
    # [Inh2 + En[0, 0, 1] <-> En[0, 1, 1],rates[kfiInh2, kriInh2]],
    # [Inh1 + En[0, 1, 0] <-> En[1, 1, 0],rates[kfiInh1, kriInh1]],
    # [Inh3 + En[0, 1, 0] <-> En[0, 1, 1],rates[kfiInh3, kriInh3]],
    # [Inh1 + En[0, 1, 1] <-> En[1, 1, 1],rates[kfiInh1, kriInh1]],
    # [Inh2 + En[1, 0, 0] <-> En[1, 1, 0],rates[kfiInh2, kriInh2]],
    # [Inh3 + En[1, 0, 0] <-> En[1, 0, 1],rates[kfiInh3, kriInh3]],
    # [Inh2 + En[1, 0, 1] <-> En[1, 1, 1],rates[kfiInh2, kriInh2]],
    # [Inh3 + En[1, 1, 0] <-> En[1, 1, 1],rates[kfiInh3, kriInh3]],
    # [Inh1 + Enx[0, 0, 0] <-> Enx[1, 0, 0],rates[kfiInh1, kriInh1]],
    # [Inh2 + Enx[0, 0, 0] <-> Enx[0, 1, 0],rates[kfiInh2, kriInh2]],
    # [Inh3 + Enx[0, 0, 0] <-> Enx[0, 0, 1],rates[kfiInh3, kriInh3]],
    # [S2 + Enx[0, 0, 0] <-> NC2[S2, Enx[0, 0, 0]],rates[kf2, kr2]],
    # [Inh1 + Enx[0, 0, 1] <-> Enx[1, 0, 1],rates[kfiInh1, kriInh1]],
    # [Inh2 + Enx[0, 0, 1] <-> Enx[0, 1, 1],rates[kfiInh2, kriInh2]],
    # [Inh1 + Enx[0, 1, 0] <-> Enx[1, 1, 0],rates[kfiInh1, kriInh1]],
    # [Inh3 + Enx[0, 1, 0] <-> Enx[0, 1, 1],rates[kfiInh3, kriInh3]],
    # [Inh1 + Enx[0, 1, 1] <-> Enx[1, 1, 1],rates[kfiInh1, kriInh1]],
    # [Inh2 + Enx[1, 0, 0] <-> Enx[1, 1, 0],rates[kfiInh2, kriInh2]],
    # [Inh3 + Enx[1, 0, 0] <-> Enx[1, 0, 1],rates[kfiInh3, kriInh3]],
    # [Inh2 + Enx[1, 0, 1] <-> Enx[1, 1, 1],rates[kfiInh2, kriInh2]],
    # [Inh3 + Enx[1, 1, 0] <-> Enx[1, 1, 1],rates[kfiInh3, kriInh3]],
    # [Inh1 + NC2[S1, En[0, 0, 0]] <-> NC2[S1, En[1, 0, 0]],rates[kfiInh1, kriInh1]],
    # [Inh2 + NC2[S1, En[0, 0, 0]] <-> NC2[S1, En[0, 1, 0]],rates[kfiInh2, kriInh2]],
    # [Inh3 + NC2[S1, En[0, 0, 0]] <-> NC2[S1, En[0, 0, 1]],rates[kfiInh3, kriInh3]],
    # [Inh1 + NC2[S1, En[0, 0, 1]] <-> NC2[S1, En[1, 0, 1]],rates[kfiInh1, kriInh1]],
    # [Inh2 + NC2[S1, En[0, 0, 1]] <-> NC2[S1, En[0, 1, 1]],rates[kfiInh2, kriInh2]],
    # [Inh1 + NC2[S1, En[0, 1, 0]] <-> NC2[S1, En[1, 1, 0]],rates[kfiInh1, kriInh1]],
    # [Inh3 + NC2[S1, En[0, 1, 0]] <-> NC2[S1, En[0, 1, 1]],rates[kfiInh3, kriInh3]],
    # [Inh1 + NC2[S1, En[0, 1, 1]] <-> NC2[S1, En[1, 1, 1]],rates[kfiInh1, kriInh1]],
    # [Inh2 + NC2[S1, En[1, 0, 0]] <-> NC2[S1, En[1, 1, 0]],rates[kfiInh2, kriInh2]],
    # [Inh3 + NC2[S1, En[1, 0, 0]] <-> NC2[S1, En[1, 0, 1]],rates[kfiInh3, kriInh3]],
    # [Inh2 + NC2[S1, En[1, 0, 1]] <-> NC2[S1, En[1, 1, 1]],rates[kfiInh2, kriInh2]],
    # [Inh3 + NC2[S1, En[1, 1, 0]] <-> NC2[S1, En[1, 1, 1]],rates[kfiInh3, kriInh3]],
    # [Inh1 + NC2[S2, Enx[0, 0, 0]] <-> NC2[S2, Enx[1, 0, 0]],rates[kfiInh1, kriInh1]],
    # [Inh2 + NC2[S2, Enx[0, 0, 0]] <-> NC2[S2, Enx[0, 1, 0]],rates[kfiInh2, kriInh2]],
    # [Inh3 + NC2[S2, Enx[0, 0, 0]] <-> NC2[S2, Enx[0, 0, 1]],rates[kfiInh3, kriInh3]],
    # [Inh1 + NC2[S2, Enx[0, 0, 1]] <-> NC2[S2, Enx[1, 0, 1]],rates[kfiInh1, kriInh1]],
    # [Inh2 + NC2[S2, Enx[0, 0, 1]] <-> NC2[S2, Enx[0, 1, 1]],rates[kfiInh2, kriInh2]],
    # [Inh1 + NC2[S2, Enx[0, 1, 0]] <-> NC2[S2, Enx[1, 1, 0]],rates[kfiInh1, kriInh1]],
    # [Inh3 + NC2[S2, Enx[0, 1, 0]] <-> NC2[S2, Enx[0, 1, 1]],rates[kfiInh3, kriInh3]],
    # [Inh1 + NC2[S2, Enx[0, 1, 1]] <-> NC2[S2, Enx[1, 1, 1]],rates[kfiInh1, kriInh1]],
    # [Inh2 + NC2[S2, Enx[1, 0, 0]] <-> NC2[S2, Enx[1, 1, 0]],rates[kfiInh2, kriInh2]],
    # [Inh3 + NC2[S2, Enx[1, 0, 0]] <-> NC2[S2, Enx[1, 0, 1]],rates[kfiInh3, kriInh3]],
    # [Inh2 + NC2[S2, Enx[1, 0, 1]] <-> NC2[S2, Enx[1, 1, 1]],rates[kfiInh2, kriInh2]],
    # [Inh3 + NC2[S2, Enx[1, 1, 0]] <-> NC2[S2, Enx[1, 1, 1]],rates[kfiInh3, kriInh3]]]
    #
    expansion = []
    rates = list(r.Rates())
    mods = list(r.MHS())
    [En,Enx] = mods
    S = list(r.LHS())
    P = list(r.RHS())
    [kf1,kr1,k1,kf2,kr2,k2] = getRatesFor(rates,'PingPong')
    [Inh1,kfiInh1,kriInh1,Inh2,kfiInh2,kriInh2,Inh3,kfiInh3,kriInh3] = getRatesFor(rates,'NCmI')
    expansion=[\
        reac(NC2(S1,En[0,0,0]),[P1,Enx[0,0,0]],k1),\
        reac(NC2(S2,Enx[0,0,0]),[P2,En[0,0,0]],k2),\
        revreacs([Inh1,En[0,0,0]],En[1,0,0],[kfiInh1,kriInh1]),\
        revreacs([Inh2,En[0,0,0]],En[0,1,0],[kfiInh2,kriInh2]),\
        revreacs([Inh3,En[0,0,0]],En[0,0,1],[kfiInh3,kriInh3]),\
        revreacs([S1,En[0,0,0]],NC2(S1,En[0,0,0]),[kf1,kr1]),\
        revreacs([Inh1,En[0,0,1]],En[1,0,1],[kfiInh1,kriInh1]),\
        revreacs([Inh2,En[0,0,1]],En[0,1,1],[kfiInh2,kriInh2]),\
        revreacs([Inh1,En[0,1,0]],En[1,1,0],[kfiInh1,kriInh1]),\
        revreacs([Inh3,En[0,1,0]],En[0,1,1],[kfiInh3,kriInh3]),\
        revreacs([Inh1,En[0,1,1]],En[1,1,1],[kfiInh1,kriInh1]),\
        revreacs([Inh2,En[1,0,0]],En[1,1,0],[kfiInh2,kriInh2]),\
        revreacs([Inh3,En[1,0,0]],En[1,0,1],[kfiInh3,kriInh3]),\
        revreacs([Inh2,En[1,0,1]],En[1,1,1],[kfiInh2,kriInh2]),\
        revreacs([Inh3,En[1,1,0]],En[1,1,1],[kfiInh3,kriInh3]),\
        revreacs([Inh1,Enx[0,0,0]],Enx[1,0,0],[kfiInh1,kriInh1]),\
        revreacs([Inh2,Enx[0,0,0]],Enx[0,1,0],[kfiInh2,kriInh2]),\
        revreacs([Inh3,Enx[0,0,0]],Enx[0,0,1],[kfiInh3,kriInh3]),\
        revreacs([S2,Enx[0,0,0]],NC2(S2,Enx[0,0,0]),[kf2,kr2]),\
        revreacs([Inh1,Enx[0,0,1]],Enx[1,0,1],[kfiInh1,kriInh1]),\
        revreacs([Inh2,Enx[0,0,1]],Enx[0,1,1],[kfiInh2,kriInh2]),\
        revreacs([Inh1,Enx[0,1,0]],Enx[1,1,0],[kfiInh1,kriInh1]),\
        revreacs([Inh3,Enx[0,1,0]],Enx[0,1,1],[kfiInh3,kriInh3]),\
        revreacs([Inh1,Enx[0,1,1]],Enx[1,1,1],[kfiInh1,kriInh1]),\
        revreacs([Inh2,Enx[1,0,0]],Enx[1,1,0],[kfiInh2,kriInh2]),\
        revreacs([Inh3,Enx[1,0,0]],Enx[1,0,1],[kfiInh3,kriInh3]),\
        revreacs([Inh2,Enx[1,0,1]],Enx[1,1,1],[kfiInh2,kriInh2]),\
        revreacs([Inh3,Enx[1,1,0]],Enx[1,1,1],[kfiInh3,kriInh3]),\
        revreacs([Inh1,NC2(S1,En[0,0,0])],NC2(S1,En[1,0,0]),[kfiInh1,kriInh1]),\
        revreacs([Inh2,NC2(S1,En[0,0,0])],NC2(S1,En[0,1,0]),[kfiInh2,kriInh2]),\
        revreacs([Inh3,NC2(S1,En[0,0,0])],NC2(S1,En[0,0,1]),[kfiInh3,kriInh3]),\
        revreacs([Inh1,NC2(S1,En[0,0,1])],NC2(S1,En[1,0,1]),[kfiInh1,kriInh1]),\
        revreacs([Inh2,NC2(S1,En[0,0,1])],NC2(S1,En[0,1,1]),[kfiInh2,kriInh2]),\
        revreacs([Inh1,NC2(S1,En[0,1,0])],NC2(S1,En[1,1,0]),[kfiInh1,kriInh1]),\
        revreacs([Inh3,NC2(S1,En[0,1,0])],NC2(S1,En[0,1,1]),[kfiInh3,kriInh3]),\
        revreacs([Inh1,NC2(S1,En[0,1,1])],NC2(S1,En[1,1,1]),[kfiInh1,kriInh1]),\
        revreacs([Inh2,NC2(S1,En[1,0,0])],NC2(S1,En[1,1,0]),[kfiInh2,kriInh2]),\
        revreacs([Inh3,NC2(S1,En[1,0,0])],NC2(S1,En[1,0,1]),[kfiInh3,kriInh3]),\
        revreacs([Inh2,NC2(S1,En[1,0,1])],NC2(S1,En[1,1,1]),[kfiInh2,kriInh2]),\
        revreacs([Inh3,NC2(S1,En[1,1,0])],NC2(S1,En[1,1,1]),[kfiInh3,kriInh3]),\
        revreacs([Inh1,NC2(S2,Enx[0,0,0])],NC2(S2,Enx[1,0,0]),[kfiInh1,kriInh1]),\
        revreacs([Inh2,NC2(S2,Enx[0,0,0])],NC2(S2,Enx[0,1,0]),[kfiInh2,kriInh2]),\
        revreacs([Inh3,NC2(S2,Enx[0,0,0])],NC2(S2,Enx[0,0,1]),[kfiInh3,kriInh3]),\
        revreacs([Inh1,NC2(S2,Enx[0,0,1])],NC2(S2,Enx[1,0,1]),[kfiInh1,kriInh1]),\
        revreacs([Inh2,NC2(S2,Enx[0,0,1])],NC2(S2,Enx[0,1,1]),[kfiInh2,kriInh2]),\
        revreacs([Inh1,NC2(S2,Enx[0,1,0])],NC2(S2,Enx[1,1,0]),[kfiInh1,kriInh1]),\
        revreacs([Inh3,NC2(S2,Enx[0,1,0])],NC2(S2,Enx[0,1,1]),[kfiInh3,kriInh3]),\
        revreacs([Inh1,NC2(S2,Enx[0,1,1])],NC2(S2,Enx[1,1,1]),[kfiInh1,kriInh1]),\
        revreacs([Inh2,NC2(S2,Enx[1,0,0])],NC2(S2,Enx[1,1,0]),[kfiInh2,kriInh2]),\
        revreacs([Inh3,NC2(S2,Enx[1,0,0])],NC2(S2,Enx[1,0,1]),[kfiInh3,kriInh3]),\
        revreacs([Inh2,NC2(S2,Enx[1,0,1])],NC2(S2,Enx[1,1,1]),[kfiInh2,kriInh2]),\
        revreacs([Inh3,NC2(S2,Enx[1,1,0])],NC2(S2,Enx[1,1,1]),[kfiInh3,kriInh3])\
    ]
    return expansion
    
#******************** End Autogenerated stub code

handlers = {'UniUni_CI_3_3':handle_UniUni_CI_3_3,
            'UniUni_NCI_3_3':handle_UniUni_NCI_3_3,
            'UniUni_NCI_3_4':handle_UniUni_NCI_3_4,
            'UniUni_UCI_3_3':handle_UniUni_UCI_3_3,
            'UniUni_3':handle_UniUni_3,
            'BiUni_3':handle_BiUni_3,
            'OrderedBiUni_5':handle_OrderedBiUni_5,
            'UniBi_3':handle_UniBi_3,
            'BiUni_CI_3_3':handle_BiUni_CI_3_3,
            'UniBi_CI_3_3':handle_UniBi_CI_3_3,
            'UniBi_CI_NCI_3_3_3':handle_UniBi_CI_NCI_3_3_3,
            'BiUni_CI_NCI_3_3_3':handle_BiUni_CI_NCI_3_3_3,
            'BiBi_3':handle_BiBi_3,
            'OrderedBiBi_5':handle_OrderedBiBi_5,
            'OrderedBiBi_CI_5_3':handle_OrderedBiBi_CI_5_3,
            'OrderedBiBi_CI1_CI2_5_3_3':handle_OrderedBiBi_CI1_CI2_5_3_3,
            'RandomBiBi_5':handle_RandomBiBi_5,
            'RandomBiBi_CI_5_3':handle_RandomBiBi_CI_5_3,
            'RandomBiBi_CI1_CI2_5_3_3':handle_RandomBiBi_CI1_CI2_5_3_3,
            'RandomBiBi_NCI_5_3':handle_RandomBiBi_NCI_5_3,
            'RandomBiBi_NCI1_NCI2_5_3_3':handle_RandomBiBi_NCI1_NCI2_5_3_3,
            'BiBi_CI_3_3':handle_BiBi_CI_3_3,
            'MulS_3':handle_MulS_3,
            'BiTer_3':handle_BiTer_3,
            'TerBi_3':handle_TerBi_3,
            'TerTer_3':handle_TerTer_3,
            'TerTer_CI_3_3':handle_TerTer_CI_3_3,
            'PingPong_6':handle_PingPong_6,
            'PingPong_NCI_6_3':handle_PingPong_NCI_6_3,
            'PingPong_NCI_6_4':handle_PingPong_NCI_6_4,
            'PingPong_NCI_6_6':handle_PingPong_NCI_6_6,
            'PingPong_NCI2_6_4':handle_PingPong_NCI2_6_4,
            'PingPong_CI_NCI_6_3_3':handle_PingPong_CI_NCI_6_3_3,
            'PingPongTerTerF_9':handle_PingPongTerTerF_9,
            'PingPongTerTerR_9':handle_PingPongTerTerR_9,
            'PingPong_NCmI_6_3':handle_PingPong_NCmI_6_3
           }

   
#****************************************************************************
def expandkMech(r):
    # print "**** Expanding kMech arrow: "+r.Input().strip()
    rates = list(r.Rates())
    mods = list(r.MHS())
    heads = map(lambda x: x[0], rates)
    lengths = map(lambda x: str(x-1), map(len, rates))
    # print " rates:     ", rates
    # print " heads:     ", heads
    # print " lengths:   ", lengths
    # print " modifiers: ", mods
    
    keyword = "_".join(map(lambda x: x[0], rates))
    keyword = "_".join(heads + lengths)
    
    # print " keyword:   ", keyword
    
    # return []
    
    print " INPUT ARROW: ", r.Input().strip(), " is ", keyword
    
    if keyword in handlers:
        h = handlers[keyword]
        kMechreactions = h(r)
        # print " OUTPUT ARROWS:(1):",kMechreactions
        kMechreactions = flatten(kMechreactions)
        # print " OUTPUT ARROWS:(2):", kMechreactions
        return kMechreactions
    else:
        print "Error: kMech handler not found for "+r.Input().strip()
    return []
#*******************************************************************************
    
