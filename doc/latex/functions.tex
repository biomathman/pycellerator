\chapter[Functions]{pycellerator Function Reference}

% *****************************************************************************************************
\underline{Conventions used in this chapter}: 

For the command line syntax:

{\tt typewriter font} is used to represent required input exactly as it should be typed

\textit{italicized Roman font} is used to represent input that should be replaced with a value, such as the name of an input file.

Items enclosed in square brackets, e.g., {\tt [ like this ]} are optional. This remark only applies to expressions typed on the command line (e.g., the terminal in linux or MacOS, or at the command prompt in Windows). It \textbf{does not apply} to reactions.

The {\tt \$} is used to indicate the command prompt is several examples. 

\underline{Reaction Syntax}: 

Examples of reactions, such as those that should be written in input files, are written in {\tt typewriter} font {\tt like this}. Note that reaction syntax requires the 
use of square brackets, and the contents of square brackets are not optional in this case. 

\section{Command Line Interface}

The generic command line syntax is

\begin{lstlisting}
 $ python pycellerator.py keyword [options]
\end{lstlisting}
 
where \CODE{keyword} is one of \CODE{EXPAND}, \CODE{INTERPRET}, \CODE{CONVERT}, \CODE{PARSE}, \CODE{SOLVE}, \CODE{SBML}, \CODE{FLUX} and \CODE{VERSION}, and {\tt [options]} is an optional sequence of command line options that is difference for each keyword. The case (upper or lower) of the {tt keyword} does not matter. The syntax and options for each keyword are discussed in the following sections. 
 
\section{parser}

The parser converts from text-based arrow notation into an internal python class (data structure) called a {\tt Reaction}.



\paragraph{Command Line Syntax:}\ \\

\begin{lstlisting}
     $ python pycellerator parse -in \textit{filename} [-dump] [-trace]}
\end{lstlisting}

\begin{lstlisting}
     $ python parser.py -in \textit{filename} [-dump] [-trace]}
\end{lstlisting}

The {\tt in \textit{filename}} specifies the input file name, which contains a list of text reactions. An example is given by the following:
\begin{lstlisting} 
 [X  <=> XP,   mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]  # first reaction
 [XP <=> XPP,  mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]  # second reaction
 [Y  <=> YP,   mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [YP <=> YPP,  mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [Z  <=> ZP,   mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
 [ZP <=> ZPP,  mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
\end{lstlisting}
One reaction may be placed per line; additional white space is ignored. The {\tt \#} character indicates a comment; 
anything written to the right of this character will be ignored. 

If the {\tt -trace} option is used, the text reaction will be written to the screen after each reaction is successfully read and parsed.

If the {\tt -dump} option is used, the {\tt Dump()} method will be applied (and written to the screen) for each reaction after it is processed, whether the reaction is successfully parsed or not. 

\paragraph{Command Line in Shell:}\ \\

\begin{lstlisting}
 >>> import pycellerator
 >>> pycellerator.run("parse -in  filename [-dump]  [-trace]")
\end{lstlisting}



\paragraph{API (functions):}

\subparagraph{\tt parser(*keywords)\\}

\begin{tabular}{ll}
\textbf{input:} & (keyword arguments only) \\
\textbf{return value:}& list of {\tt Reactions}s  \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
{\tt inputfile=""} & Name of input file containing reactions.\\
{\tt trace=False} & Turns on tracing, same as command line {\tt -trace}
\end{tabular}

\subparagraph{\tt ParseArrow(r)\\}

\begin{tabular}{ll}
\textbf{input:} & {\tt r}: String reaction in pycellerator format. \\
\textbf{return value:} & {\tt Reaction} object representing the input \\
& text reaction.  Operationally, there is no difference between invoking \\
& {\tt ParseArrow(r)} and {\tt Reaction(r)}; the difference is that one \\
& invokes the class directly and the other does it via a functional interface.
\end{tabular}

\clearpage
\paragraph{API (class):}

\subparagraph{\tt Reaction(r)\\}

\begin{tabular}{ll}
\textbf{input:} & {\tt r}: String reaction in pycellerator format. \\ \\
\multicolumn{2}{l}{\textbf{Methods:}}\\
{\tt r.Input()} & value of the original text reaction\\
{\tt r.Parsed()} & output of the {\tt pyparsing} module\\
{\tt r.Number()} & number of sequential calls to parser\\
{\tt r.Length()} & length of the {\tt pyparsing} object\\
{\tt r.ArrowType()} & Cellerator arrow type as a string\\
{\tt r.Arrow()} & Actual arrow as a string\\
{\tt r.LHS()} & List of reactants\\
{\tt r.RHS()} & List of products\\
{\tt r.LH\_STOIC()} & Stoichiometry of reactants (mass action only)\\
{\tt r.RH\_STOIC()} & Stoichiometry of products (mass action only)\\
{\tt r.MHS()} & List of modifiers\\
{\tt r.Rates()} & List of rate constants or parameters in reaction\\
{\tt r.Dump()} & Produce a formatted dump of the {\tt Reaction} class object
\end{tabular}
\begin{center}
\begin{minipage}{4in}
Comparison of {\tt Arrow()} and {\tt ArrowType()}. See previous chapter for descriptions of corresponding reactions.\\
\begin{center}
\begin{tabular}{|ll|}
\hline
{\tt r.Arrow()} & {\tt r.ArrowType()} \\
\hline
\verb!"->"!  & \verb!"Mass Action"! \\
\verb!"-->"! & \verb!"Mass Action"! \\
\verb!"<->"! & \verb!"Mass Action"! \\
\verb!"=>"!  & \verb!"Mass Action"! \\
\verb!"<=>"! & \verb!"Mass Action"! \\
\verb!":->"! & \verb!"MMH"! \\
\verb!":-->"! &\verb!"MMH"! \\
\verb!":=>"! & \verb!"Mass Action"! \\
\verb!"|->"! & \verb!"GRN"! \\
\verb!|-->"! & \verb!"GRN"! \\
\verb!"==>"! & \verb!"Multiuse-Arrow"! \\
\hline
\end{tabular}
\end{center}
\end{minipage}
\end{center}

\paragraph{Examples.\\}


\begin{enumerate}
\item Input with {-trace}
 
\begin{lstlisting}
 $more catalytic.dat
  [X => Y, mod[E], rates[k1,k2,k3]]
  [Y => X, mod[F], rates[k4,k5,k6]]
 $python pycellerator.py -in catalytic.dat -trace
  py[cellerator]: parser (2015-03-02 17:58:18)
  input: [X => Y, mod[E], rates[k1,k2,k3]]
  input: [Y => X, mod[F], rates[k4,k5,k6]]
  [<__main__.Reaction object at 0x7f0442369a50>, 
    <__main__.Reaction object at 0xe47dd0>]
\end{lstlisting}
 

\item Input with {-dump}
\begin{lstlisting}
 
$cat sto.dat
  [ 3A + 4B -> P + Q + R,  k]
$ python pyx.py -in sto.dat -dump
py[xlr8r]: parser (2012-03-02 18:08:54)
======================= Reaction Number  1  =======================
Input:     [ 3A + 4B -> P + Q + R,  k]
Parsed:    [(['3', 'A', '4', 'B'], {}), '->', 
            (['P', 'Q', 'R'], {}), (['k'], {})]
Arrow:     ->
ArrowType: Mass Action
LHS:       ['A', 'B']
LH_STOIC:  ['3', '4']
RHS:       ['P', 'Q', 'R']
RH_STOIC:  ['1', '1', '1']
modifiers: []
rates:     ['k']
[<__main__.Reaction object at 0x7f6b1c3d2c90>]
\end{lstlisting}
 




\end{enumerate}



% *****************************************************************************************************
%\newpage

\section{expander}

Normally there is no need for the user to call the expander directly. 

The expander module expands complex py[xlr8r] reactions into their constituent parts; for example, the catalytic reaction 
$$ S + E \underset{k_2}{\overset {k_1}{\rightleftharpoons}} SE \overset{k_3}{\to} P+E $$
is broken down into its constituent reactions
\begin{align*}
S+E &\overset{k_1}{\to} SE\\
SE &\overset{k_2}{\to S+E}\\
SE &\overset{k_3}{\to P+E}
\end{align*}

The input to the expander is a list of reactions in text from, or the name of a file containing a list of such reactions, one line per file.

The output of the expander is a list of the expanded reactions, either as {\tt Reaction} objects, or a list of text reactions, or both. 


\paragraph{Command Line Syntax:}\ 

\begin{lstlisting}
 $ python expander.py -in  inputfile  [-dump] [-out   outputfile]
\end{lstlisting}

\begin{lstlisting}
 $ python pycellerator.py expand -in inputfile [-dump] [-out  outputfile]
\end{lstlisting}


The {\tt \textit{inputfile}} may be either a reaction file or a model file. If it is a model file it must have file extension {\tt .model}. 

If the {\tt -dump} option is specified the text output of the expander will be spewed to the screen as a list
of text output reactions (compatible in format to input text reactions). 

If the {\tt -out} option is specified the text output of the expander will be written to the requested file. If no
file name is given a default file name will be generated (e.g., {\tt expanded-reactions.out}). 

Existing files will not be over-written; if the requested file already exists a new file name will be generated that is based on the requested file name but has a unique string attached to the end of it.



\paragraph{Command Line in Shell:}\ \\

 
\begin{lstlisting}
 >>> import pycellerator
 >>> pycellerator.run ("expand -in inputfile [-dump] [-out } outputfile]")
\end{lstlisting}




\paragraph{API:}

\subparagraph{\tt expand(r)\\}

\begin{tabular}{ll}
\textbf{input:} & single {\tt Reaction} or list of {\tt Reaction}s \\
\textbf{return value:}& list of expanded {\tt Reaction}s (see parser) \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}} \\
none
\end{tabular}


\subparagraph{\tt expandReactions(filename)\\}

\begin{tabular}{ll}
\textbf{input:} & name of input file \\
\textbf{return value:}& list of {\tt Reaction}s (see parser) \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
\tt{dump = False} & if {\tt True}, print text reactions to screen \\
\tt{text = False} & if {\tt True}, return list of text reactions\\
& instead of {\tt Reaction}s.
\end{tabular}

\paragraph{Example Input File:}

Here is an example of a typical input file, followed by a full example of the dump command using th  an shorter input file.

\begin{lstlisting} 
 [X  <=> XP,   mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]
 [XP <=> XPP,  mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]
 [Y  <=> YP,   mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [YP <=> YPP,  mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [Z  <=> ZP,   mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
 [ZP <=> ZPP,  mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
\end{lstlisting}

\paragraph{Full Example}

In the following example, we will dump a model that is generated from a single line file. 

\begin{lstlisting}
$ more test.dat
  [X :=> Y,   mod[Z], rates[k1,k2,k3,k4,k5]]
$
$ python expander.py -in test.dat -dump -out test.out
py[cellerator]: expander (2015-09-01 10:39:34)
[X+Z->X_Z,k1]
[X_Z->X+Z,k2]
[X_Z->Z_Y,k3]
[Z_Y->X_Z,k4]
[Z_Y->Y+Z,k5]
[Y+Z->Z_Y,0]
Output written to: test.out
$
$ more test.out
[X+Z->X_Z,k1]
[X_Z->X+Z,k2]
[X_Z->Z_Y,k3]
[Z_Y->X_Z,k4]
[Z_Y->Y+Z,k5]
[Y+Z->Z_Y,0]
$
\end{lstlisting}


% *****************************************************************************************************

%\newpage

\section{interpreter}

The interpreter converts reactions from arrow format into differential equations.  The functionality of the interpreter module is analogous to that of the Cellerator {\tt interpret} command. 

\paragraph{Command Line Syntax:}\ 

\begin{lstlisting}
 $ python interpreter.py -in filename -out filename]
     [ -dump ]
     [ -format FORMAT]
     [ -frozen variable variable ...]
\end{lstlisting}

\begin{lstlisting}
  $ python pycellerator.py interpret -in  filename -out filename]
     [ -dump ]
     [ -format FORMAT]
     [ -frozen variable variable ...]
\end{lstlisting}
}

The input \textit{filename} may be either a reaction file or a model file. If it is a model file it must have a file extension of \CODE{.model}. Here is an example reaction file:

\begin{lstlisting} 
[Br + BrO3 -> HBrO2 + HOBr, k1] 
[Br + HBrO2 -> 2*HOBr, k2]
[BrO3 + HBrO2 -> 2*Ce + 2*HBrO2, k3] 
[2*HBrO2-> BrO3 + HOBr, k4] 
[Ce -> 0.5*Br, k5]
\end{lstlisting}

If the \CODE{-dump} option is specified the \CODE{Reaction} object database will be dumped to the screen.

If the \CODE{-out} option is specified the text output of the interpreter will be written to the requested file. If no file name is given a default file name will be generated (e.g., \CODE{interpreted -out reactions.out}). 

If the \CODE{-out} option is not used, the result will be written to the screen.

Existing files will not be over-written; if the requested file already exists a new file name will be generated that is based on the requested file name but has a unique string attached to the end of it.

Output formats are \CODE{ODE} (default), \CODE{CODE}, \CODE{PYTHON}, \CODE{LATEX}, \CODE{DICT}, \CODE{JACOBIAN}, \CODE{STEADYSTATE} and are not case-sensitive.


\clearpage

\CODE{-format ODE} will return a text-formatted table of differential equations. Here is an example of \CODE{ODE} format:

\begin{lstlisting}
BrO3' = -Br*BrO3*k1 - BrO3*HBrO2*k3 + k4*HBrO2**2.0
HOBr' = Br*BrO3*k1 + 2.0*Br*HBrO2*k2 + k4*HBrO2**2.0
Br' = 0.5*Ce*k5 - Br*BrO3*k1 - Br*HBrO2*k2
HBrO2' = Br*BrO3*k1 + BrO3*HBrO2*k3 - Br*HBrO2*k2 - 2.0*k4*HBrO2**2.0
Ce' = -Ce*k5 + 2.0*BrO3*HBrO2*k3
\end{lstlisting}

\CODE{-format CODE} or \CODE{-format=PYTHON} will return a python function that will evaluate the differential equations. Here is an example of the output of the \CODE{CODE} or \CODE{PYTHON} format:

\begin{lstlisting}[frame=single]
def f(y,t):
    y[0] = BrO3
    y[0] = HOBr
    y[0] = Br
    y[0] = HBrO2
    y[0] = Ce
    yp[0] = -Br*BrO3*k1 - BrO3*HBrO2*k3 + k4*HBrO2**2.0
    yp[1] = Br*BrO3*k1 + 2.0*Br*HBrO2*k2 + k4*HBrO2**2.0
    yp[2] = 0.5*Ce*k5 - Br*BrO3*k1 - Br*HBrO2*k2
    yp[3] = Br*BrO3*k1 + BrO3*HBrO2*k3 - Br*HBrO2*k2 - 2.0*k4*HBrO2**2.0
    yp[4] = -Ce*k5 + 2.0*BrO3*HBrO2*k3
    return (yp)
\end{lstlisting}

Note that this code is not directly useable because the values of parameters are not specified. Also, this is not the same code that is returned by the solver module, as that code has the rate constants fully instantiated, unless the \textit{inputfile} following the \CODE{-in} option is a model file with file extension \CODE{.model} that has all of the rate constants fully defined in the \CODE{\$RATES} block. 

\CODE{-format LATEX} will return a \LaTeX\ encoding of the equations within a minimal wrapper that makes it compatible with both \CODE{latex} and \CODE{pdflatex}. 
This option uses the \CODE{sympy latex} function and may not produce the expected output. 
For example, the above file will produce

\begin{lstlisting}
	\documentclass[12pt,letterpaper]{article}
	\usepackage[latin1]{inputenc}
	\usepackage{amsmath, amsfonts, amssymb}
	\author{py[xlr8r]}
	\date{\today}
	\title{Automatically Generated Equations}
	\begin{document}
	\maketitle
	\begin{align*}
	BrO3' &=  Br BrO_{3} k_{1} - BrO_{3} HBrO_{2} k_{3} + 
		HBrO_{2}^{2.0} k_{4\\
	HOBr' &= r BrO_{3} k_{1} + 2.0 Br HBrO_{2} k_{2} + 
		HBrO_{2}^{2.0} k_{4\\
	Br' &=  Br BrO_{3} k_{1} - Br HBrO_{2} k_{2} + 0.5 Ce k_{5\\
	HBrO2' &= r BrO_{3} k_{1} - Br HBrO_{2} k_{2} + 
		BrO_{3} HBrO_{2} k_{3} - 2.0 HBrO_{2}^{2.0} k_{4\\
	Ce' &= .0 BrO_{3} HBrO_{2} k_{3} - Ce k_{5\\
	\end{align*}
	\end{document}
\end{lstlisting}

\clearpage

\CODE{-format DICT} will return a python dictionary of the form\CODE{{"variable":ode, "variable":ode,...}} where each \CODE{ ode} is the right-hand side of the symbolic differential equation for the corresponding variable. Here is an example of a dictionary: 
\begin{lstlisting}
{'BrO3': -Br*BrO3*k1 - BrO3*HBrO2*k3 + k4*HBrO2**2.0, 
 'HOBr': Br*BrO3*k1 + 2.0*Br*HBrO2*k2 + k4*HBrO2**2.0, 
 'Br': 0.5*Ce*k5 - Br*BrO3*k1 - Br*HBrO2*k2, 
 'HBrO2': Br*BrO3*k1 + BrO3*HBrO2*k3 - Br*HBrO2*k2 - 2.0*k4*HBrO2**2.0, 
 'Ce': -Ce*k5 + 2.0*BrO3*HBrO2*k3}
\end{lstlisting}


\CODE{-format JACOBIAN} will return the Jacobian matrix of the system: 

\begin{lstlisting}[xleftmargin=0in, xrightmargin=0in]
$ python pyx.py interpret -in oregonator.dat -format Jacobian
[-Br*k1 - HBrO2*k3, 0,             -BrO3*k1,        -BrO3*k3 + 2*HBrO2*k4,      0]
[            Br*k1, 0, BrO3*k1 + 2*HBrO2*k2,         2*Br*k2 + 2*HBrO2*k4,      0]
[           -Br*k1, 0,  -BrO3*k1 - HBrO2*k2,                       -Br*k2, 0.5*k5]
[ Br*k1 + HBrO2*k3, 0,   BrO3*k1 - HBrO2*k2, BrO3*k3 - Br*k2 - 4*HBrO2*k4,      0]
[       2*HBrO2*k3, 0,                    0,                    2*BrO3*k3,    -k5]
\end{lstlisting}


\CODE{-format STEADYSTATE} will return the steady state of the system. Consider, for example, the following simple model \CODE{simple.model}:
\begin{lstlisting}
$Reactions
 [2*A -> B, k]
 [B -> Nil, k1]
 [B -> A, k2]
 [Nil -> A, k3]
$IC
 A=1
 B=1
$Rates
 k=1
 k1=1
 k2=.1
 k3 = 1
$
\end{lstlisting}
This model has a single realizable (physical) steady state and a second non-realizable steady state (with negative concentrations).
\begin{lstlisting}
$ python pycellerator.py interpret -in simple.model -format steadystate
There are 2 steady states
(A, B) = (-0.723746864455746, 0.476190476190476) has eigenvalues 
        [2.85841999579395, -1.06343253797097]
(A, B) = (0.723746864455746, 0.476190476190476) has eigenvalues 
        [-1.02268894521036, -2.97229851261262]
$
\end{lstlisting}

\clearpage 
The \CODE{-symbolic} option may be used in conjunction with \CODE{-format STEADYSTATE} to return a tuple \CODE{(vars,ss,evs)}, where \CODE{vars} is a tuple of the system variables; \CODE{ss} is a list of the steady states, each as a tuple; and \CODE{evs} is a list of the eigenvalues of the Jacobian at that steady state. This format is probably more meaningful form within the Python Shell: 

\begin{lstlisting}
>>> import pycellerator.interpreter as interp
>>> s,ss,evs=interp.interpret("simple.model",
    format="steadystate",symbolic=True)
>>> s
[A, B]
>>> ss
[(-0.723746864455746, 0.476190476190476), 
 (0.723746864455746, 0.476190476190476)]
>>> evs
[[2.85841999579395, -1.06343253797097], 
 [-1.02268894521036, -2.97229851261262]]
>>>
\end{lstlisting}



If the \CODE{-frozen} option is used it should be followed by one or more unquoted variable names in the model. These variables will be treated as frozen variables, i.e., the right hand sides of their differential equations will be set to zero. Note that these may also be additional variables that are not otherwise specified in the model equations, in which case additional equations will be added to the file. 


\paragraph{Command Line in Shell:}\ \\

\begin{lstlisting}
 >>> import pycellerator
 >>> pycellerator.run ("interpret -in inputfile [ -out filename]
	 [ -dump ] [ -format FORMAT][ -frozen variable variable ..]
	 [ -symbolic] ")
\end{lstlisting}



\paragraph{API:\\}

\subparagraph {\CODE{ makeODETerms(r, s, *keywords)}\\}

\begin{tabular}{ll}
\textbf{input:} & {\tt r}: list of reactions as {\tt Reaction} class objects\\
 & {\tt s}: dictionary of sympy symbols as \verb!{"var":symbol,"var":symbol,...}!\\

\textbf{return value:}& dictionary of ode right-hand-sides by text name of variable, as in \\
& \verb!{"var":ode, "var":ode,...}! - the {\tt var}'s in the dictionary\\
& are the same as those in {\tt s}. \\ \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
\tt{frozen = []} & list of variables, given by the text equivalents, whose differential \\
& equations are held fixed, as in \verb.frozen=["var1","var2",...]. The entries in the \\
& return dictionary will be \verb!.."var1":0,"var2":0,..! for these variables.
\end{tabular}
\clearpage

\subparagraph{\CODE{interpret(filename, *keywords)}\\}

\begin{tabular}{ll}
\textbf{input:} & name of input file \\
\textbf{return value:}& text table of differential equations, as per keywords \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
\tt{format = "ODE"} & same as command line {\tt ODE} format\\
& other options are {\tt "DICT","CODE","PYTHON"},\\ &{\tt "JACOBIAN","STEADYSTATE"}\\
\tt{symbolic = False} & set to {\tt True} to get a symbolic Steady state tuple\\
\tt{dumpparser="False"} &  same as command line {\tt Dump} \\
\tt{ofile=""} & name of output file
\end{tabular}



\paragraph{Example:}

This example uses the input file illustrated above.


\begin{lstlisting}
$ python interpreter.py -in oregonator.dat -frozen BrO3 -format code
py[cellerator]: interpreter (2015-09-02 11:53:09)
def f(y,t):
    y[0] = Ce
    y[0] = HOBr
    y[0] = HBrO2
    y[0] = BrO3
    y[0] = Br
    yp[0] = -Ce*k5 + 2.0*BrO3*HBrO2*k3
    yp[1] = Br*BrO3*k1 + 2.0*Br*HBrO2*k2 + k4*HBrO2**2.0
    yp[2] = Br*BrO3*k1 + BrO3*HBrO2*k3 - Br*HBrO2*k2 - 2.0*k4*HBrO2**2.0
    yp[3] = 0
    yp[4] = 0.5*Ce*k5 - Br*BrO3*k1 - Br*HBrO2*k2
    return (yp)
$
\end{lstlisting}

% *****************************************************************************************************

%\newpage
\section{solver}

The solver will write a stand-alone python script to run a simulation on a model, and then will execute that script. 
\paragraph{Command Line Syntax:}\ 

 


\begin{lstlisting}
     $ python pycellerator.py solve -in filename
              [-run  stepsize duration]
              [-plot  variable variable variable ...]]
              [-plotcolumns  n]
              [-sameplot]
              [-out filename} ]
              [-format  FORMAT} ]
              [-pyfile  filename}]
              [-norun]
              \end{lstlisting}

or
\clearpage
\begin{lstlisting}
     $ python solver.py -in  filename
              [-run  stepsize duration]
              [-plot  variable variable variable ...]]
              [-plotcolumns  n]
              [-sameplot]
              [-out filename} ]
              [-format  FORMAT} ]
              [-pyfile  filename}]
              [-norun]
              \end{lstlisting}


\CODE{-in filename} specifies the name of the model file.

\CODE{-run  stepsize duration}  specifies the step size (for plotting 
and output files) and duration of the run. The default values are 100 and 1. 

\CODE{-plot  variable variable variable }  - if \CODE{ -plot} is used 
alone, without any variable names, all variables are plotted on a grid. If any variables are listed, then only the requested variables are plotted. 

\CODE{-plotcolumns n}  defines the number of columns to use in the grid of plots (default is 3). Only used in conjunction with the \CODE{-plot} option. 

\CODE{-sameplot} - the variables will all be plotted on a single graph rather than a grid. This options supersedes \CODE{-plotcolumns}. 

\CODE{-out filename}  - optional output file to write the solution to  at the requested step size (as given in \CODE{ -run} option). 

\CODE{-format FORMAT} - format of output file; values of \CODE{FORMAT} are \CODE{CSV} (comma-separated values); \CODE{TSV} (tab-separated values); and \CODE{TABLE} (space-separated values). The default format is \CODE{CSV}. 

\CODE{-norun} - just generate the code, don't run it. 

\CODE{-mxstep n} - the default number of steps in \CODE{ ODEINT} is 500. This is increased to 500000 by {\tt pycellerator}. 

\CODE{-pyfile  filename}  gives the name of the python code to be generated, otherwise a default file name will be used. Existing files will not be overwritten, so if the file already exists, and approximation to the requested file name will be used instead. 


\paragraph{Command Line in Shell:}\ \\

 
\begin{lstlisting}
 >>>import pycellerator
 >>> pycellerator.run("interpret -in inputfile 
                       [-run stepsize duration]
                       [-plot [ variable variable variable ...]
                       [-plotcolumns n]
                       [-sameplot] 
                       [-out filename ]
                       [-format FORMAT ]
                       [-pyfile filename ]
                       [-norun]")
\end{lstlisting}


% *****************************************************************************************************
\newpage
\section{converter}

The converter module is will convert \CODE{pycellerator} text reactions to {\tt Cellerator} ({\tt xlr8r}) \textit{Mathematica} reaction notebooks. 

The reactions will be specified in their \textit{Mathematica} {\tt FullForm} notation, so that they can be written as ASCII text files. This notation can be read directly or copied and pasted directly into an xlr8r notebook and is fully compatible with the xlr8r {\tt interpret} and {\tt run} commands.

Note that \LaTeX\ output is provided by the interpreter module, and SBML  input and output is provided by the SBML module.

\paragraph{Command Line Syntax:}\ \\

\begin{lstlisting}
 $ python pycellerator.py convert  -in filename [-out filename] [-dump]
\end{lstlisting}


The \CODE{-in  filename} specifies the input file name, which is a list of text pycellerator reactions, identical in format to the reactions sent to the parser, such as: 

\begin{lstlisting} 
 [X  <=> XP,   mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]
 [XP <=> XPP,  mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]
 [Y  <=> YP,   mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [YP <=> YPP,  mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [Z  <=> ZP,   mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
 [ZP <=> ZPP,  mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
\end{lstlisting}

The input \CODE{filename} may also be a model file (with file extension \CODE{.model}. In this case the output will include not only {\tt xlr8r} reactions, but lists of initial conditions and rate constants in formats compatible with the {\tt xlr8r run} function. 

The \CODE{-out filename} specifies the output file name. which is typically a \textit{Mathematica} notebook. If it is not specified a unique file name will be generated. The contents of this file will typically look something like this: 
\begin{lstlisting}
model = {
 List[Underoverscript[RightArrowLeftArrow[X, XP], ZPP, Z],
      a, d, k, 0, a, d, k ,0],
 List[Underoverscript[RightArrowLeftArrow[XP, XPP], ZPP, Z],
      a, d, k, 0, a, d, k, 0],
 List[Underoverscript[RightArrowLeftArrow[Y, YP], XPP, X], 
      a, d, k, 0, a, d, k, 0],
 List[Underoverscript[RightArrowLeftArrow[YP, YPP], XPP, X],
      a, d, k, 0, a, d, k, 0],
 List[Underoverscript[RightArrowLeftArrow[Z, ZP], YPP, Y], 
      a, d, k, 0, a, d, k, 0],
 List[Underoverscript[RightArrowLeftArrow[ZP, ZPP], YPP, Y],
      a, d, k, 0, a, d, k, 0]}
\end{lstlisting}

The \CODE{ -dump} option indicates that the intermediate {\tt Reaction} database should be dumped to the screen. 

\newpage

\paragraph{Command Line in Shell:}\ 

\begin{lstlisting}
 >>> import pycellerator
 >>> pycellerator.run("convert -in  filename [-out  filename] [-dump]")
\end{lstlisting}

\paragraph{API:\\}

\subparagraph{\CODE{ convert(*keywords)}\\}

\begin{tabular}{ll}
\textbf{input:} & (by keyword only)\\
\textbf{return value:}& full path name of output file \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
\tt{inputfile=""} & Name of file containing pycellerator reactions to be converted\\
\tt{outputfile=""} & Requested name of outputfile. If the file already exists \\
& the name will be modified to generate a unique file name. \\
& If not specified a unique default name will be generated.
\end{tabular}

% *****************************************************************************************************
%\newpage
\section[SBML]{SBML Support}



\subsection{Reading SBML Files}


When an SBML model is read, it is converted to a {\tt py[cellerator]} model file.  A model file that is generated from an SBML model will typically look somewhat different from a hand-generated model because the reactions and other structures will not normally correspond to the typical biological entities that we think of as reactions.

Rather than running models directly from SBML, the \CODE{SBML read} command converts an SBML model directly into a pycellerator model file. This arrow file can be used like any other pycellerator model file. SBML entities that are not implemented in pycellerator but are referenced in the SBML file cannot be converted to pycellerator. 



\subsubsection{Syntax}

\begin{lstlisting}
  python pycellerator.py sbml read -in filename [-model filename]
\end{lstlisting}
If \CODE{-model fjiename} is specified, the output will be written to the specified file. Otherwise the output will be written to the file \CODE{tmp.model}. Existing files will not be overwritten, and an approximation to the requested name will be used if the file already exists. 


\textbf{Caution}: Unexpected errors could occur if variables (e.g., \CODE{species}) in the SBML model are the same as predefined functions in python, particularly \CODE{sympy} functions. For example, model 9 (Huang, 1996, ``Ultrasensitivity in the MAPK Cascade'') 
in the Biomodels database (\url{https://www.ebi.ac.uk/biomodels-main/BIOMD0000000009}) contains the variable \CODE{E1} which is also the name of an elliptic integral function in \CODE{sympy}. Attempting to convert this model directly would produce the somewhat obscure looking error
\begin{lstlisting}
TypeError: unsupported operand type(s) for *: 'Symbol' and 'function'
\end{lstlisting}
To fix this, the user is fore-warned to change the names of all symbols, such as \CODE{E1}, to non-conflicting symbols. 

In the following example, Biomodel 9 species \CODE{E1} was converted globally (in a text editor) to a new species \CODE{Species\_E1} prior to use. The revised SBML file was saved in a new file \CODE{BM9.xml}. To convert this file to a {\tt pycellerator} model file \CODE{BM9.model}, use


\begin{lstlisting}
 python pycellerator.py SBML READ -in BM9.xml -model BM9.model
\end{lstlisting}

The following model file was generated from the biomodels file
\begin{lstlisting}[xleftmargin=0in,xrightmargin=0in]
$ASSIGNMENTS
 K_PP_norm=(KPase_PP_K + PP_K)/(K + KPase_PP_K + KPase_P_K + 
           PP_K + PP_KK_K + PP_KK_P_K + P_K)
 rel_K_PP_max=1.11105062057732*K_PP_norm
 KK_PP_norm=(KKPase_PP_KK + PP_KK + PP_KK_K + PP_KK_P_K)/(KK + KKPase_PP_KK + 
 KKPase_P_KK + PP_KK + PP_KK_K + PP_KK_P_K + P_KK + P_KKK_KK + P_KKK_P_KK)
 KKK_P_norm=(P_KKK + P_KKK_KK + P_KKK_P_KK)/(KKK + P_KKK + P_KKK_KK + P_KKK_P_KK)
 r1a=compartment*(1000.0*KKK*Species_E1 - 150.0*Species_E1_KKK)
 r1b=150.0*Species_E1_KKK*compartment
 r2a=compartment*(1000.0*E2*P_KKK - 150.0*E2_P_KKK)
 r2b=150.0*E2_P_KKK*compartment
 r3a=compartment*(1000.0*KK*P_KKK - 150.0*P_KKK_KK)
 r3b=150.0*P_KKK_KK*compartment
 r4a=compartment*(1000.0*KKPase*P_KK - 150.0*KKPase_P_KK)
 r4b=150.0*KKPase_P_KK*compartment
 r5a=compartment*(1000.0*P_KK*P_KKK - 150.0*P_KKK_P_KK)
 r5b=150.0*P_KKK_P_KK*compartment
 r6a=compartment*(1000.0*KKPase*PP_KK - 150.0*KKPase_PP_KK)
 r6b=150.0*KKPase_PP_KK*compartment
 r7a=compartment*(1000.0*K*PP_KK - 150.0*PP_KK_K)
 r7b=150.0*PP_KK_K*compartment
 r8a=compartment*(1000.0*KPase*P_K - 150.0*KPase_P_K)
 r8b=150.0*KPase_P_K*compartment
 r9a=compartment*(1000.0*PP_KK*P_K - 150.0*PP_KK_P_K)
 r9b=150.0*PP_KK_P_K*compartment
 r10a=compartment*(1000.0*KPase*PP_K - 150.0*KPase_PP_K)
 r10b=150.0*KPase_PP_K*compartment
$REACTIONS
 [Species_E1 -> Nil, using["r1a/compartment"]]
 [Nil -> Species_E1_KKK, using["r1a/compartment"]]
 [KKK -> Nil, using["r1a/compartment"]]
 [Nil -> Species_E1, using["r1b/compartment"]]
 [Species_E1_KKK -> Nil, using["r1b/compartment"]]
 [Nil -> P_KKK, using["r1b/compartment"]]
 [Nil -> E2_P_KKK, using["r2a/compartment"]]
 [P_KKK -> Nil, using["r2a/compartment"]]
 [E2 -> Nil, using["r2a/compartment"]]
 [E2_P_KKK -> Nil, using["r2b/compartment"]]
 [Nil -> KKK, using["r2b/compartment"]]
 [Nil -> E2, using["r2b/compartment"]]
 [KK -> Nil, using["r3a/compartment"]]
 [Nil -> P_KKK_KK, using["r3a/compartment"]]
 [P_KKK -> Nil, using["r3a/compartment"]]
 [P_KKK_KK -> Nil, using["r3b/compartment"]]
 [Nil -> P_KK, using["r3b/compartment"]]
 [Nil -> P_KKK, using["r3b/compartment"]]
 [Nil -> KKPase_P_KK, using["r4a/compartment"]]
 [P_KK -> Nil, using["r4a/compartment"]]
 [KKPase -> Nil, using["r4a/compartment"]]
 [KKPase_P_KK -> Nil, using["r4b/compartment"]]
 [Nil -> KK, using["r4b/compartment"]]
 [Nil -> KKPase, using["r4b/compartment"]]
 [Nil -> P_KKK_P_KK, using["r5a/compartment"]]
 [P_KK -> Nil, using["r5a/compartment"]]
 [P_KKK -> Nil, using["r5a/compartment"]]
 [P_KKK_P_KK -> Nil, using["r5b/compartment"]]
 [Nil -> PP_KK, using["r5b/compartment"]]
 [Nil -> P_KKK, using["r5b/compartment"]]
 [Nil -> KKPase_PP_KK, using["r6a/compartment"]]
 [PP_KK -> Nil, using["r6a/compartment"]]
 [KKPase -> Nil, using["r6a/compartment"]]
 [KKPase_PP_KK -> Nil, using["r6b/compartment"]]
 [Nil -> P_KK, using["r6b/compartment"]]
 [Nil -> KKPase, using["r6b/compartment"]]
 [Nil -> PP_KK_K, using["r7a/compartment"]]
 [K -> Nil, using["r7a/compartment"]]
 [PP_KK -> Nil, using["r7a/compartment"]]
 [PP_KK_K -> Nil, using["r7b/compartment"]]
 [Nil -> PP_KK, using["r7b/compartment"]]
 [Nil -> P_K, using["r7b/compartment"]]
 [Nil -> KPase_P_K, using["r8a/compartment"]]
 [P_K -> Nil, using["r8a/compartment"]]
 [KPase -> Nil, using["r8a/compartment"]]
 [KPase_P_K -> Nil, using["r8b/compartment"]]
 [Nil -> K, using["r8b/compartment"]]
 [Nil -> KPase, using["r8b/compartment"]]
 [Nil -> PP_KK_P_K, using["r9a/compartment"]]
 [PP_KK -> Nil, using["r9a/compartment"]]
 [P_K -> Nil, using["r9a/compartment"]]
 [Nil -> PP_K, using["r9b/compartment"]]
 [PP_KK_P_K -> Nil, using["r9b/compartment"]]
 [Nil -> PP_KK, using["r9b/compartment"]]
 [PP_K -> Nil, using["r10a/compartment"]]
 [Nil -> KPase_PP_K, using["r10a/compartment"]]
 [KPase -> Nil, using["r10a/compartment"]]
 [Nil -> KPase, using["r10b/compartment"]]
 [KPase_PP_K -> Nil, using["r10b/compartment"]]
 [Nil -> P_K, using["r10b/compartment"]]
$RATES
 K_PP_norm_max=0.900049
 compartment=4e-12
$IC
 Species_E1=3e-05
 E2=0.0003
 KKK=0.003
 P_KKK=0.0
 KK=1.2
 P_KK=0.0
 PP_KK=0.0
 K=1.2
 P_K=0.0
 PP_K=0.0
 KPase=0.12
 KKPase=0.0003
 Species_E1_KKK=0.0
 E2_P_KKK=0.0
 P_KKK_KK=0.0
 P_KKK_P_KK=0.0
 PP_KK_K=0.0
 PP_KK_P_K=0.0
 KKPase_PP_KK=0.0
 KKPase_P_KK=0.0
 KPase_PP_K=0.0
 KPase_P_K=0.0
 K_PP_norm=0.0
 KK_PP_norm=0.0
 KKK_P_norm=0.0
 rel_K_PP_max=0.0
\end{lstlisting}

This file can support simulations as with any other model file, e.g. 
\begin{lstlisting}
 python pycellerator.py solve -in BM9.model -plot
\end{lstlisting}

\subsubsection{Supported Features}

The following SBML features are not supported by {\tt pycellerator} and will be ignored in SBML models: \CODE{unitDefinitions}, \CODE{compartmentTypes}, \CODE{speciesTypes}, \CODE{initialAssignments},  \CODE{algebraicRules}, \CODE{constraints}, and  \CODE{events}.  Support for these features may be added at a later date. 
Since some of the structures need to be translated, and the way things are evaluated may not correspond to the expected rules of SBML evaluation, as described in the following paragraphs.


\begin{enumerate}
\item All variables that have either their \CODE{boundaryCondition} or \CODE{constant} flag set to \CODE{True} are converted to \CODE{Frozen} variables in the model. This means that they may be set by \CODE{using} reactions or by \CODE{assignment} statements. Either of these could potentially conflict with the intent of the SBML model. For example, if the \CODE{constant} field is set to \CODE{True}, SBML says that such variables should never change, but if either a rate or assignment rule is present in the SBML model it will be used in the {\tt pycellerator} model (technically this would be an invalid SBML model, so should  not lead to problems). However, if both values are set to \CODE{False} and the variable is set in both a rule and a reaction, then there could be a combination of assignments and ODES for that variable, in conflict with the intent of the SBML (again this would be invalid SBML, so the situation should not arise). 
\item If a \CODE{parameter} is a \CODE{variable} in an \CODE{assignmentRule} and has a \CODE{value} in a \CODE{parameter} statement, then the \CODE{value} in the \CODE{parameter} statement will take precedence and the \CODE{assignmentRule} will be ignored. 
\item All \CODE{rateRules} are converted to \CODE{"using"} reactions of the form \CODE{Nil -> Variable} and the \CODE{variable} is added to the list of \CODE{frozen} variables, so that it cannot be changed by any other reactions. 
\item All reaction \CODE{kineticLaws} are assigned to {\tt assignment} statements with the same variable as the reaction \CODE{id}. 
\item Each \CODE{reaction} is converted to a collection of \CODE{using} creation and annihilation reactions, with one reaction for each species in the reaction. The reaction will always have the form of \CODE{ X -> Nil} or \CODE{Nil -> X}, depending on the net stoichiometry of the species in the reaction. Thus, for example, if the SBML file has a reaction 
\begin{lstlisting}
A + 3B -> 2A + B + C
\end{lstlisting}
with a kinetic law \CODE{K}, 
the following {\tt pycellerator} reactions will be generated:
\begin{lstlisting}
 [Nil -> A, using["K/VA"]]
 [B -> Nil, using["2*K/VB"]]
 [Nil -> C, using["K/VC"]]
\end{lstlisting}
where \CODE{VA}, \CODE{VB}, and \CODE{VC} are the volumes of the compartments that species \CODE{A}, \CODE{B} and \CODE{C} reside in, respectively. All of the stoichiometries inside the \CODE{using} expression are expressed as positive quantities because the sign will be calculated automatically by the interpreter module, because the reaction {\tt [X -> Nil, using["K"]]} will produce the same ODE term as \CODE{[Nil -> X, using["-K"]]}, namely, ${\tt[X]}'=-{\tt K}$.

\item At each integration step, all \CODE{assignmentRules} (with their parameter values instantiated) are evaluated before the differential equations are updated.  Thus a differential equation may refer to any variable defined by an \CODE{assignmentRule}
\item All functions defined in the \CODE{listOfFunctions} are instantiated globally so that any rule or reaction may refer to them. 


\end{enumerate}




\subsection{Writing SBML Files}

Not all features of SBML are supported. Only reactions, initial conditions, and parameters are written to the SBML file. Functions and assignment rules are not written to SBML in the present version.

\subsubsection{Syntax}

\begin{lstlisting}
 python pycellerator.py SBML write -in file [-out filename]
\end{lstlisting}

SBML files are very lengthy so only a very simple example will be given here. Consider the model file \CODE{catalytic.model}
\begin{lstlisting}
$Reactions
 [X => Y, mod[E], rates[k1,k2,k3]]
 [Y -> Nil, k]
$IC
 X = 1.0
 Y = 0.0
 E = 1.0
$Rates
 k1 = 1.0
 k2 = 1.0
 k3 = 1.0
 k = .001
\end{lstlisting}
To convert this to SBML, the syntax is
\begin{lstlisting}
 python pycellerator.py SBML WRITE -in catalytic.model
\end{lstlisting}
Here is the output.
\begin{lstlisting}[xrightmargin=0in]
<?xml version="1.0" encoding="UTF-8"?>
<sbml xmlns="http://www.sbml.org/sbml/level3/version1/core" level="3" 
		version="1">
  <model substanceUnits="item" timeUnits="dimensionless" extentUnits="item">
    <listOfCompartments>
      <compartment id="compartment" spatialDimensions="3" size="1"
      	 units="dimensionless" constant="true"/>
    </listOfCompartments>
    <listOfSpecies>
      <species id="Y" compartment="compartment" initialAmount="0" 
      	hasOnlySubstanceUnits="true" boundaryCondition="false" 
      	constant="false"/>
      <species id="X" compartment="compartment" initialAmount="1" 
      	hasOnlySubstanceUnits="true" boundaryCondition="false" 
      	constant="false"/>
      <species id="E" compartment="compartment" initialAmount="1" 
      	hasOnlySubstanceUnits="true" boundaryCondition="false" 
      	constant="false"/>
      <species id="Nil" compartment="compartment" initialAmount="0" 
      	hasOnlySubstanceUnits="true" boundaryCondition="false" 
      	constant="false"/>
    </listOfSpecies>
    <listOfParameters>
      <parameter id="k3" value="1" units="dimensionless" constant="true"/>
      <parameter id="k2" value="1" units="dimensionless" constant="true"/>
      <parameter id="k1" value="1" units="dimensionless" constant="true"/>
      <parameter id="k" value="0.001" units="dimensionless" 
      constant="true"/>
    </listOfParameters>
    <listOfReactions>
      <reaction id="r1" reversible="false" fast="false">
        <listOfReactants>
          <speciesReference species="X" stoichiometry="1" constant="false"/>
          <speciesReference species="E" stoichiometry="1" constant="false"/>
        </listOfReactants>
        <listOfProducts>
          <speciesReference species="X_E" stoichiometry="1" constant="false"/>
        </listOfProducts>
        <kineticLaw>
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <apply>
              <times/>
              <ci> E </ci>
              <ci> X </ci>
              <ci> k1 </ci>
            </apply>
          </math>
        </kineticLaw>
      </reaction>
      <reaction id="r2" reversible="false" fast="false">
        <listOfReactants>
          <speciesReference species="X_E" stoichiometry="1" constant="false"/>
        </listOfReactants>
        <listOfProducts>
          <speciesReference species="X" stoichiometry="1" constant="false"/>
          <speciesReference species="E" stoichiometry="1" constant="false"/>
        </listOfProducts>
        <kineticLaw>
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <apply>
              <times/>
              <ci> X_E </ci>
              <ci> k2 </ci>
            </apply>
          </math>
        </kineticLaw>
      </reaction>
      <reaction id="r3" reversible="false" fast="false">
        <listOfReactants>
          <speciesReference species="X_E" stoichiometry="1" constant="false"/>
        </listOfReactants>
        <listOfProducts>
          <speciesReference species="Y" stoichiometry="1" constant="false"/>
          <speciesReference species="E" stoichiometry="1" constant="false"/>
        </listOfProducts>
        <kineticLaw>
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <apply>
              <times/>
              <ci> X_E </ci>
              <ci> k3 </ci>
            </apply>
          </math>
        </kineticLaw>
      </reaction>
      <reaction id="r4" reversible="false" fast="false">
        <listOfReactants>
          <speciesReference species="Y" stoichiometry="1" constant="false"/>
        </listOfReactants>
        <listOfProducts>
          <speciesReference species="Nil" stoichiometry="1" constant="false"/>
        </listOfProducts>
        <kineticLaw>
          <math xmlns="http://www.w3.org/1998/Math/MathML">
            <apply>
              <times/>
              <ci> Y </ci>
              <ci> k </ci>
            </apply>
          </math>
        </kineticLaw>
      </reaction>
    </listOfReactions>
  </model>
</sbml>
\end{lstlisting}

