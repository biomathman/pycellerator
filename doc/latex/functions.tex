\chapter[Functions]{pycellerator Function Reference}

% *****************************************************************************************************
\underline{Conventions used in this chapter}: 

For the command line syntax:

{\tt typewriter font} is used to represent required input exactly as it should be typed

\textit{italicized Roman font} is used to represent input that should be replaced with a value, such as the name of an input file.

Items enclosed in square brackets, e.g., {\tt [ like this ]} are optional. This remark only applies to expressions typed on the command line (e.g., the terminal in linux or MacOS, or at the command prompt in Windows). It \textbf{does not apply} to reactions.

The {\tt \$} is used to indicate the command prompt is several examples. 

\underline{Reaction Syntax}: 

Examples of reactions, such as those that should be written in input files, are written in {\tt typewriter} font {\tt like this}. Note that reaction syntax requires the 
use of square brackets, and the contents of square brackets are not optional in this case. 


 
\section{parser}

The parser converts from text-based arrow notation into an internal python class (data structure) called a {\tt Reaction}.



\paragraph{Command Line Syntax:}\ \\

\fbox{
\begin{minipage}{\textwidth}
{\tt \$ python pycellerator parse -in \textit{filename} [-dump] [-trace]}

\vspace{12pt}
{\tt \$ python parser.py -in \textit{filename} [-dump] [-trace]}
\end{minipage}
}

The {\tt in \textit{filename}} specifies the input file name, which contains a list of text reactions. An example is given by the following:
\begin{Verbatim}[frame=single]
 [X  <=> XP,   mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]  # first reaction
 [XP <=> XPP,  mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]  # second reaction
 [Y  <=> YP,   mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [YP <=> YPP,  mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [Z  <=> ZP,   mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
 [ZP <=> ZPP,  mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
\end{Verbatim}
One reaction may be placed per line; additional white space is ignored. The {\tt \#} character indicates a comment; 
anything written to the right of this character will be ignored. 

If the {\tt -trace} option is used, the text reaction will be written to the screen after each reaction is successfully read and parsed.

If the {\tt -dump} option is used, the {\tt Dump()} method will be applied (and written to the screen) for each reaction after it is processed, whether the reaction is successfully parsed or not. 

\paragraph{Command Line in Shell:}\ \\

\fbox{
\begin{minipage}{\textwidth}
{\tt >>> import pyx}\\
{\tt >>> pyx.run("parse -in \textit{filename} {\tt [-dump]} {\tt [-trace]}")}
\end{minipage}
}


\paragraph{API (functions):}

\subparagraph{\tt parser(*keywords)\\}

\begin{tabular}{ll}
\textbf{input:} & (keyword arguments only) \\
\textbf{return value:}& list of {\tt Reactions}s  \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
{\tt inputfile=""} & Name of input file containing reactions.\\
{\tt trace=False} & Turns on tracing, same as command line {\tt -trace}
\end{tabular}

\subparagraph{\tt ParseArrow(r)\\}

\begin{tabular}{ll}
\textbf{input:} & {\tt r}: String reaction in pycellerator format. \\
\textbf{return value:} & {\tt Reaction} object representing the input \\
& text reaction.  Operationally, there is no difference between invoking \\
& {\tt ParseArrow(r)} and {\tt Reaction(r)}; the difference is that one \\
& invokes the class directly and the other does it via a functional interface.
\end{tabular}


\paragraph{API (class):}

\subparagraph{\tt Reaction(r)\\}

\begin{tabular}{ll}
\textbf{input:} & {\tt r}: String reaction in pycellerator format. \\ \\
\multicolumn{2}{l}{\textbf{Methods:}}\\
{\tt r.Input()} & value of the original text reaction\\
{\tt r.Parsed()} & output of the {\tt pyparsing} module\\
{\tt r.Number()} & number of sequential calls to parser\\
{\tt r.Length()} & length of the {\tt pyparsing} object\\
{\tt r.ArrowType()} & Cellerator arrow type as a string\\
{\tt r.Arrow()} & Actual arrow as a string\\
{\tt r.LHS()} & List of reactants\\
{\tt r.RHS()} & List of products\\
{\tt r.LH\_STOIC()} & Stoichiometry of reactants (mass action only)\\
{\tt r.RH\_STOIC()} & Stoichiometry of products (mass action only)\\
{\tt r.MHS()} & List of modifiers\\
{\tt r.Rates()} & List of rate constants or parameters in reaction\\
{\tt r.Dump()} & Produce a formatted dump of the {\tt Reaction} class object
\end{tabular}
\begin{center}
\begin{minipage}{4in}
Comparison of {\tt Arrow()} and {\tt ArrowType()}. See previous chapter for descriptions of corresponding reactions.\\
\begin{center}
\begin{tabular}{|ll|}
\hline
{\tt r.Arrow()} & {\tt r.ArrowType()} \\
\hline
\verb!"->"!  & \verb!"Mass Action"! \\
\verb!"-->"! & \verb!"Mass Action"! \\
\verb!"<->"! & \verb!"Mass Action"! \\
\verb!"=>"!  & \verb!"Mass Action"! \\
\verb!"<=>"! & \verb!"Mass Action"! \\
\verb!":->"! & \verb!"MMH"! \\
\verb!":-->"! &\verb!"MMH"! \\
\verb!":=>"! & \verb!"Mass Action"! \\
\verb!"|->"! & \verb!"GRN"! \\
\verb!|-->"! & \verb!"GRN"! \\
\verb!"==>"! & \verb!"Multiuse-Arrow"! \\
\hline
\end{tabular}
\end{center}
\end{minipage}
\end{center}

\paragraph{Examples.\\}

\begin{enumerate}
\item Input with {-trace}
\begin{small}
\begin{Verbatim}[frame=single]
 $more catalytic.dat
  [X => Y, mod[E], rates[k1,k2,k3]]
  [Y => X, mod[F], rates[k4,k5,k6]]
 $python pyx.py -in catalytic.dat -trace
  py[xlr8r]: parser (2012-03-02 17:58:18)
  input: [X => Y, mod[E], rates[k1,k2,k3]]
  input: [Y => X, mod[F], rates[k4,k5,k6]]
  [<__main__.Reaction object at 0x7f0442369a50>, 
    <__main__.Reaction object at 0xe47dd0>]
\end{Verbatim}
\end{small}

\item Input with {-dump}
\begin{small}
\begin{Verbatim}[frame=single]
$cat sto.dat
  [ 3A + 4B -> P + Q + R,  k]
$ python pyx.py -in sto.dat -dump
py[xlr8r]: parser (2012-03-02 18:08:54)
======================= Reaction Number  1  =======================
Input:     [ 3A + 4B -> P + Q + R,  k]
Parsed:    [(['3', 'A', '4', 'B'], {}), '->', 
            (['P', 'Q', 'R'], {}), (['k'], {})]
Arrow:     ->
ArrowType: Mass Action
LHS:       ['A', 'B']
LH_STOIC:  ['3', '4']
RHS:       ['P', 'Q', 'R']
RH_STOIC:  ['1', '1', '1']
modifiers: []
rates:     ['k']
[<__main__.Reaction object at 0x7f6b1c3d2c90>]
\end{Verbatim}
\end{small}




\end{enumerate}



% *****************************************************************************************************
\newpage

\section{expander}

Normally there is no need for the user to call the expander directly. 

The expander module expands complex py[xlr8r] reactions into their constituent parts; for example, the catalytic reaction 
$$ S + E \underset{k_2}{\overset {k_1}{\rightleftharpoons}} SE \overset{k_3}{\to} P+E $$
is broken down into its constituent reactions
\begin{align*}
S+E &\overset{k_1}{\to} SE\\
SE &\overset{k_2}{\to S+E}\\
SE &\overset{k_3}{\to P+E}
\end{align*}

The input to the expander is a list of reactions in text from, or the name of a file containing a list of such reactions, one line per file.

The output of the expander is a list of the expanded reactions, either as {\tt Reaction} objects, or a list of text reactions, or both. 


\paragraph{Command Line Syntax:}\ 

\fbox{
\begin{minipage}{\textwidth}
{\tt \$ python expander.py -in \textit{inputfile}} {\tt [-dump] [-out  \textit{outputfile}} {\tt ]}
\vspace{12pt}

{\tt \$ python pycellerator.py expand -in \textit{inputfile}} {\tt [-dump] [-out  \textit{outputfile}} {\tt ]}
\end{minipage}
}

The {\tt \textit{inputfile}} may be either a reaction file or a model file. If it is a model file it must have file extension {\tt .model}. 

If the {\tt -dump} option is specified the text output of the expander will be spewed to the screen as a list
of text output reactions (compatible in format to input text reactions). 

If the {\tt -out} option is specified the text output of the expander will be written to the requested file. If no
file name is given a default file name will be generated (e.g., {\tt expanded-reactions.out}). 

Existing files will not be over-written; if the requested file already exists a new file name will be generated that is based on the requested file name but has a unique string attached to the end of it.



\paragraph{Command Line in Shell:}\ \\

\fbox{
\begin{minipage}{\textwidth}
{\tt >>> import pyx}\\
{\tt >>> pyx.run ("expand -in \textit{inputfile} {\tt [-dump] [-out } \textit{outputfile}{\tt ]")}}
\end{minipage}
}



\paragraph{API:}

\subparagraph{\tt expand(r)\\}

\begin{tabular}{ll}
\textbf{input:} & single {\tt Reaction} or list of {\tt Reaction}s \\
\textbf{return value:}& list of expanded {\tt Reaction}s (see parser) \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}} \\
none
\end{tabular}


\subparagraph{\tt expandReactions(filename)\\}

\begin{tabular}{ll}
\textbf{input:} & name of input file \\
\textbf{return value:}& list of {\tt Reaction}s (see parser) \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
\tt{dump = False} & if {\tt True}, print text reactions to screen \\
\tt{text = False} & if {\tt True}, return list of text reactions\\
& instead of {\tt Reaction}s.
\end{tabular}

\paragraph{Example Input File:}
\begin{Verbatim}[frame=single]
 [X  <=> XP,   mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]
 [XP <=> XPP,  mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]
 [Y  <=> YP,   mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [YP <=> YPP,  mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [Z  <=> ZP,   mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
 [ZP <=> ZPP,  mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
\end{Verbatim}

\paragraph{Full Example}

\begin{verbatim}
$ more test.dat
  [X :=> Y,   mod[Z], rates[k1,k2,k3,k4,k5]]
$
$ python expander.py -in test.dat -dump -out test.out
py[xlr8r]: expander (2012-03-01 10:39:34)
[X+Z->X_Z,k1]
[X_Z->X+Z,k2]
[X_Z->Z_Y,k3]
[Z_Y->X_Z,k4]
[Z_Y->Y+Z,k5]
[Y+Z->Z_Y,0]
Output written to: test.out
$
$ more test.out
[X+Z->X_Z,k1]
[X_Z->X+Z,k2]
[X_Z->Z_Y,k3]
[Z_Y->X_Z,k4]
[Z_Y->Y+Z,k5]
[Y+Z->Z_Y,0]
$
\end{verbatim}


% *****************************************************************************************************

\newpage

\section{interpreter}

The interpreter converts reactions from arrow format into differential equations.  The functionality of the interpreter module is analogous to that of the Cellerator {\tt interpret} command. 

\paragraph{Command Line Syntax:}\ 

\fbox{
\begin{minipage}{\textwidth}
{\tt \$ python interpreter.py -in \textit{filename} [-out  \textit{filename}]}
{\tt [ -dump ]} 
{\tt [ -format \textit{format}]} 
{\tt [ -frozen \textit{variable variable ...}]}

\vspace{12pt}
{\tt \$ python pycellerator interpret -in \textit{filename}  [-out \textit{filename}]}
{\tt [ -dump ]} 
{\tt [ -format \textit{format}]} 
{\tt [ -frozen \textit{variable variable ...}]}
\end{minipage}
}

The input \textit{filename} may be either a reaction file or a model file. If it is a model file it must have a file extension of {\tt .model}. Here is an example reaction file:

\begin{Verbatim}[frame=single]
[Br + BrO3 -> HBrO2 + HOBr, k1] 
[Br + HBrO2 -> 2*HOBr, k2]
[BrO3 + HBrO2 -> 2*Ce + 2*HBrO2, k3] 
[2*HBrO2-> BrO3 + HOBr, k4] 
[Ce -> 0.5*Br, k5]
\end{Verbatim}

If the {\tt -dump} option is specified the {\tt Reaction} object database will be dumped to the screen.

If the {\tt -out} option is specified the text output of the interpreter will be written to the requested file. If no
file name is given a default file name will be generated (e.g., {\tt interpreted- reactions.out}). 

If the {\tt -out} option is not used, the result will be written to the screen.

Existing files will not be over-written; if the requested file already exists a new file name will be generated that is based on the requested file name but has a unique string attached to the end of it.

Output formats are {\tt ODE} (default), {\tt CODE}, {\tt PYTHON}, {\tt LATEX}, {\tt DICT}, {\tt JACOBIAN}, {\tt STEADYSTATE} and are not case-sensitive.

{\tt -format ODE} will return a text-formatted table of differential equations. Here is an example of {\tt ODE} format:

\begin{Verbatim}[frame=single]
BrO3' = -Br*BrO3*k1 - BrO3*HBrO2*k3 + k4*HBrO2**2.0
HOBr' = Br*BrO3*k1 + 2.0*Br*HBrO2*k2 + k4*HBrO2**2.0
Br' = 0.5*Ce*k5 - Br*BrO3*k1 - Br*HBrO2*k2
HBrO2' = Br*BrO3*k1 + BrO3*HBrO2*k3 - Br*HBrO2*k2 - 2.0*k4*HBrO2**2.0
Ce' = -Ce*k5 + 2.0*BrO3*HBrO2*k3
\end{Verbatim}

{\tt -format CODE} or {\tt -format=PYTHON} will return a python function that will evaluate the differential equations. Here is an example of the output of the {\tt CODE} or {\tt PYTHON} format:

\begin{Verbatim}[frame=single]
def f(y,t):
    y[0] = BrO3
    y[0] = HOBr
    y[0] = Br
    y[0] = HBrO2
    y[0] = Ce
    yp[0] = -Br*BrO3*k1 - BrO3*HBrO2*k3 + k4*HBrO2**2.0
    yp[1] = Br*BrO3*k1 + 2.0*Br*HBrO2*k2 + k4*HBrO2**2.0
    yp[2] = 0.5*Ce*k5 - Br*BrO3*k1 - Br*HBrO2*k2
    yp[3] = Br*BrO3*k1 + BrO3*HBrO2*k3 - Br*HBrO2*k2 - 2.0*k4*HBrO2**2.0
    yp[4] = -Ce*k5 + 2.0*BrO3*HBrO2*k3
    return (yp)
\end{Verbatim}

Note that this code is not directly useable because the values of parameters are not specified. Also, this is not the same code that is returned by the solver module, as that code has the rate constants fully instantiated, unless the \textit{inputfile} following the {\tt -in} option is a model file with file extension {\tt model} that has all of the rate constants fully defined in the {\tt \$RATES} block. 

{\tt -format LATEX} will return a \LaTeX encoding of the equations within a minimal wrapper that makes it compatible with both {\tt latex} and {\tt pdflatex}. 
This option uses the {\tt sympy latex} function and may not produce the expected output. 
For example, the above file will produce

\begin{Verbatim}[frame=single]
	\documentclass[12pt,letterpaper]{article}
	\usepackage[latin1]{inputenc}
	\usepackage{amsmath, amsfonts, amssymb}
	\author{py[xlr8r]}
	\date{\today}
	\title{Automatically Generated Equations}
	\begin{document}
	\maketitle
	\begin{align*}
	BrO3' &=  Br BrO_{3} k_{1} - BrO_{3} HBrO_{2} k_{3} + 
		HBrO_{2}^{2.0} k_{4\\
	HOBr' &= r BrO_{3} k_{1} + 2.0 Br HBrO_{2} k_{2} + 
		HBrO_{2}^{2.0} k_{4\\
	Br' &=  Br BrO_{3} k_{1} - Br HBrO_{2} k_{2} + 0.5 Ce k_{5\\
	HBrO2' &= r BrO_{3} k_{1} - Br HBrO_{2} k_{2} + 
		BrO_{3} HBrO_{2} k_{3} - 2.0 HBrO_{2}^{2.0} k_{4\\
	Ce' &= .0 BrO_{3} HBrO_{2} k_{3} - Ce k_{5\\
	\end{align*}
	\end{document}
\end{Verbatim}

{\tt -format DICT} will return a python dictionary of \verb!{"variable":ode, "variable":ode,...}! where each {\tt ode} is the right-hand side of the symbolic differential equation for the corresponding variable. Here is an example of a dictionary: 
\begin{Verbatim}[frame=single]
{'BrO3': -Br*BrO3*k1 - BrO3*HBrO2*k3 + k4*HBrO2**2.0, 
 'HOBr': Br*BrO3*k1 + 2.0*Br*HBrO2*k2 + k4*HBrO2**2.0, 
 'Br': 0.5*Ce*k5 - Br*BrO3*k1 - Br*HBrO2*k2, 
 'HBrO2': Br*BrO3*k1 + BrO3*HBrO2*k3 - Br*HBrO2*k2 - 2.0*k4*HBrO2**2.0, 
 'Ce': -Ce*k5 + 2.0*BrO3*HBrO2*k3}
\end{Verbatim}


{\tt -format JACOBIAN} will return the Jacobian matrix of the system: 

\begin{footnotesize}
\begin{Verbatim}[frame=single]
$ python pyx.py interpret -in oregonator.dat -format Jacobian
  [-Br*k1 - HBrO2*k3, 0,             -BrO3*k1,        -BrO3*k3 + 2*HBrO2*k4,      0]
  [            Br*k1, 0, BrO3*k1 + 2*HBrO2*k2,         2*Br*k2 + 2*HBrO2*k4,      0]
  [           -Br*k1, 0,  -BrO3*k1 - HBrO2*k2,                       -Br*k2, 0.5*k5]
  [ Br*k1 + HBrO2*k3, 0,   BrO3*k1 - HBrO2*k2, BrO3*k3 - Br*k2 - 4*HBrO2*k4,      0]
  [       2*HBrO2*k3, 0,                    0,                    2*BrO3*k3,    -k5]
$ 
\end{Verbatim}
\end{footnotesize}


{\tt -format STEADYSTATE} will return the steady state of the system. Consider, for example, the following simple model {\tt simple.model}:
\begin{footnotesize}
\begin{Verbatim}[frame=single]
$Reactions
 [2*A -> B, k]
 [B -> Nil, k1]
 [B -> A, k2]
 [Nil -> A, k3]
$IC
 A=1
 B=1
$Rates
 k=1
 k1=1
 k2=.1
 k3 = 1
$
\end{Verbatim}
\end{footnotesize}
This model has a single realizable (physical) steady state and a second non-realizable steady state (with negative concentrations).
\begin{Verbatim}[frame=single]
$ python pyx.py interpret -in simple.model -format steadystate
There are 2 steady states
(A, B) = (-0.723746864455746, 0.476190476190476) has eigenvalues 
        [2.85841999579395, -1.06343253797097]
(A, B) = (0.723746864455746, 0.476190476190476) has eigenvalues 
        [-1.02268894521036, -2.97229851261262]
$
\end{Verbatim}

The {\tt -symbolic} option may be used in conjunction with {\tt -format STEADYSTATE} to return a tuple ${\tt (vars,ss,evs)}$, where {\tt vars} is a tuple of the system variables; {\tt ss} is a list of the steady states, each as a tuple; and {\tt evs} is a list of the eigenvalues of the Jacobian at that steady state. This format is probably more meaningful form within the Python Shell: 

\begin{footnotesize}
\begin{Verbatim}[frame=single]
>>> import pycellerator.interpreter as interp
>>> s,ss,evs=interp.interpret("simple.model",format="steadystate",symbolic=True)
>>> s
[A, B]
>>> ss
[(-0.723746864455746, 0.476190476190476), (0.723746864455746, 0.476190476190476)]
>>> evs
[[2.85841999579395, -1.06343253797097], [-1.02268894521036, -2.97229851261262]]
>>>
\end{Verbatim}
\end{footnotesize}



If the {\tt -frozen} option is used it should be followed by one or more unquoted variable names in the model. These variables will be treated as frozen variables, i.e., the right hand sides of their differential equations will be set to zero. Note that these may also be additional variables that are not otherwise specified in the model equations, in which case additional equations will be added to the file. 


\paragraph{Command Line in Shell:}\ \\

\fbox{
\begin{minipage}{\textwidth}
{\tt >>> import pyx}\\
{\tt >>> pyx.run ("interpret -in \textit{inputfile} 
{\tt [-out} \textit{filename} {\tt ]}
{\tt [ -dump ]} \\
{\tt [ -format} \textit{format}{\tt ]} 
{\tt [ -frozen} \textit{variable variable ...} {\tt ] [ -symbolic]}
")}
\end{minipage}
}


\paragraph{API:\\}

\subparagraph{\tt makeODETerms(r, s, *keywords)\\}

\begin{tabular}{ll}
\textbf{input:} & {\tt r}: list of reactions as {\tt Reaction} class objects\\
 & {\tt s}: dictionary of sympy symbols as \verb!{"var":symbol,"var":symbol,...}!\\

\textbf{return value:}& dictionary of ode right-hand-sides by text name of variable, as in \\
& \verb!{"var":ode, "var":ode,...}! - the {\tt var}'s in the dictionary\\
& are the same as those in {\tt s}. \\ \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
\tt{frozen = []} & list of variables, given by the text equivalents, whose differential \\
& equations are held fixed, as in \verb.frozen=["var1","var2",...]. The entries in the \\
& return dictionary will be \verb!.."var1":0,"var2":0,..! for these variables.
\end{tabular}

\subparagraph{\tt interpret(filename, *keywords)\\}

\begin{tabular}{ll}
\textbf{input:} & name of input file \\
\textbf{return value:}& text table of differential equations, as per keywords \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
\tt{format = "ODE"} & same as command line {\tt ODE} format\\
& other options are {\tt "DICT","CODE","PYTHON"},\\ &{\tt "JACOBIAN","STEADYSTATE"}\\
\tt{symbolic = False} & set to {\tt True} to get a symbolic Steady state tuple\\
\tt{dumpparser="False"} &  same as command line {\tt Dump} \\
\tt{ofile=""} & name of output file
\end{tabular}



\paragraph{Example:}

This example uses the input file illustrated above.

\begin{Verbatim}[frame=single]
$ python interpreter.py -in oregonator.dat -frozen BrO3 -format code
py[xlr8r]: interpreter (2012-03-02 11:53:09)
def f(y,t):
    y[0] = Ce
    y[0] = HOBr
    y[0] = HBrO2
    y[0] = BrO3
    y[0] = Br
    yp[0] = -Ce*k5 + 2.0*BrO3*HBrO2*k3
    yp[1] = Br*BrO3*k1 + 2.0*Br*HBrO2*k2 + k4*HBrO2**2.0
    yp[2] = Br*BrO3*k1 + BrO3*HBrO2*k3 - Br*HBrO2*k2 - 2.0*k4*HBrO2**2.0
    yp[3] = 0
    yp[4] = 0.5*Ce*k5 - Br*BrO3*k1 - Br*HBrO2*k2
    return (yp)
$
\end{Verbatim}

% *****************************************************************************************************

\newpage
\section{solver}

The solver will write a stand-alone python script to run a simulation on a model, and then will execute that script. 
\paragraph{Command Line Syntax:}\ 

\fbox{
\begin{minipage}{\textwidth}
{\tt \$ python solver.py -in \textit{filename} }
{\tt [-run  \textit{stepsize duration}]}
{\tt [-plot [\textit{variable variable variable ...}]]}  
{\tt [-plotcolumns \textit{n}]}
{\tt [-sameplot]}
{\tt [-out\textit{filename} ]}
{\tt [-format \textit{format} ]}
{\tt [-pyfile \textit{filename}]}
{\tt [-norun]}

\vspace{18pt}

{\tt \$ python pyx.py solve -in \textit{filename} }
{\tt [-run \textit{stepsize duration}  ]}
{\tt [-plot [\textit{variable variable variable ...}]]}  
{\tt [-plotcolumns \textit{n}]}
{\tt [-sameplot]}
{\tt [-out \textit{filename}]}
{\tt [-format \textit{format}]}
{\tt [-pyfile \textit{filename}]}
{\tt [-norun]}
\end{minipage}
}

{\tt -in \textit{filename}} specifies the name of the model file.

{\tt -run  \textit{stepsize duration}} - specifies the step size (for plotting and output files) and duration of the run. The default values are 100 and 1. 

{\tt -plot [\textit{variable variable variable ...} \tt ]}  - if {\tt -plot} is used alone, without any variable names, all variables are plotted on a grid. If any variables are listed, then only the requested variables are plotted. 

{\tt -plotcolumns} \textit{n}  - number of columns to use in the grid of plots (default is 3). Only used in conjunction with the {\tt -plot} option. 

{\tt -sameplot} - the variables will all be plotted on a single graph rather than a grid. This options supersedes {\tt -plotcolumns}. 

{\tt -out \textit{filename}}  - optional output file to write the solution to to at the requested step size (as given in {\tt -run} option). 

{\tt -format \textit{format}} - format of output file; values of \textit{format} are {\tt CSV} (comma-separated values); {\tt TSV} (tab-separated values); and {\tt TABLE} (space-separated values). The default format is {\tt CSV}. 

{\tt -norun} - just generate the code, don't run it. 

{\tt -mxstep n} - the default number of steps in {\tt ODEINT} is 500. This is increased to 500000 by {\tt pycellerator}. 

{\tt -pyfile \textit{filename}} - gives the name of the python code to be generated, otherwise a default file name will be used. Existing files will not be overwritten, so if the file already exists, and approximation to the requested file name will be used instead. 


\paragraph{Command Line in Shell:}\ \\

\fbox{
\begin{minipage}{\textwidth}
{\tt >>> import pyx}\\
{\tt >>> pyx.run ("interpret -in \textit{inputfile} 
{\tt [-run } \textit{stepsize duration} {\tt ]}
{\tt [-plot [}\textit{variable variable variable ...} {\tt ]]}  
{\tt [-plotcolumns} \textit{n} {\tt ]}
{\tt [-sameplot]}
{\tt [-out} \textit{filename} {\tt ]}
{\tt [-format} \textit{format} {\tt ]}
{\tt [-pyfile} \textit{filename} {\tt]}
{\tt [-norun]}
")}
\end{minipage}
}

% *****************************************************************************************************
\newpage
\section{converter}

The converter module is will convert {\tt pycellerator} text reactions to {\tt Cellerator} ({\tt xlr8r}) \textit{Mathematica} reaction notebooks. 

The reactions will be specified in their \textit{Mathematica} {\tt FullForm} notation, so that they can be written as ASCII text files. This notation can be read directly or copied and pasted directly into an xlr8r notebook and is fully compatible with the xlr8r {\tt interpret} and {\tt run} commands.

Still to be implemented functions of the converter: SBML input/output, Cambium input/output.

Note that \LaTeX output is provided by the interpreter module.  

\paragraph{Command Line Syntax:}\ \\

\fbox{\begin{minipage}{\textwidth}
{\tt \$ python converter.py -in \textit{filename}}
{\tt [-out \textit{filename}}
{\tt ] [-dump]}
\end{minipage}
}

The {\tt -in \textit{filename}} specifies the input file name, which is a list of text pycellerator reactions, identical in format to the reactions sent to the parser, such as: 

\begin{Verbatim}[frame=single]
 [X  <=> XP,   mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]
 [XP <=> XPP,  mod[Z, ZPP], rates[a, d, k, 0, a, d, k]]
 [Y  <=> YP,   mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [YP <=> YPP,  mod[X, XPP], rates[a, d, k, 0, a, d, k]] 
 [Z  <=> ZP,   mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
 [ZP <=> ZPP,  mod[Y, YPP], rates[a, d, k, 0, a, d, k]]
\end{Verbatim}

The input {\tt \textit{filename}} may also be a model file (with file extension {\tt .model}). In this case the output will include not only {\tt xlr8r} reactions, but lists of initial conditions and rate constants in formats compatible with the {\tt xlr8r run} function. 

The {\tt -out \textit{filename}} specifies the output file name. which is typically a \textit{Mathematica} notebook. If it is not specified a unique file name will be generated. The contents of this file will typically look something like this: 
\begin{footnotesize}
\begin{Verbatim}[frame=single]
model = {List[Underoverscript[RightArrowLeftArrow[X, XP], ZPP, Z],a,d,k,0,a,d,k,0],
 List[Underoverscript[RightArrowLeftArrow[XP, XPP], ZPP, Z], a, d, k, 0, a, d, k, 0],
 List[Underoverscript[RightArrowLeftArrow[Y, YP], XPP, X], a, d, k, 0, a, d, k, 0],
 List[Underoverscript[RightArrowLeftArrow[YP, YPP], XPP, X], a, d, k, 0, a, d, k, 0],
 List[Underoverscript[RightArrowLeftArrow[Z, ZP], YPP, Y], a, d, k, 0, a, d, k, 0],
 List[Underoverscript[RightArrowLeftArrow[ZP, ZPP], YPP, Y], a, d, k, 0, a, d, k, 0]}
\end{Verbatim}
\end{footnotesize}

The {\tt -dump} option indicates that the intermediate {\tt Reaction} database should be dumped to the screen. 

\newpage

\paragraph{Command Line in Shell:}\ 

\fbox{\begin{minipage}{\textwidth}

{\tt >>> import pyx}\\
{\tt >>> pyx.run("convert -in \textit{filename} [-out \textit{filename}] [-dump]")}

\end{minipage}}

\paragraph{API:\\}

\subparagraph{\tt convert(*keywords)\\}

\begin{tabular}{ll}
\textbf{input:} & (by keyword only)\\
\textbf{return value:}& full path name of output file \\  \\
\multicolumn{2}{l}{\textbf{Optional keyword arguments:}}\\
\tt{inputfile=""} & Name of file containing pycellerator reactions to be converted\\
\tt{outputfile=""} & Requested name of outputfile. If the file already exists \\
& the name will be modified to generate a unique file name. \\
& If not specified a unique default name will be generated.
\end{tabular}

% *****************************************************************************************************
\newpage
\section[SBML]{SBML Support}

\subsection{Reading SBML Files}

\subsubsection{Supported Features}

The following SBML features are not supported by {\tt py[xlr8r]} and will be ignored in SBML models: \hfill {\tt unitDefinitions}, {\tt compartmentTypes}, {\tt speciesTypes}, {\tt initialAssignments}, \\{ \tt algebraicRules},  {\tt constraints}, and  {\tt events}.  Support for these features may be added at a later date. 

When an SBML model is read, it is converted to a {\tt py[xlr8r]} model file.  A model file that is generated from an SBML model will typeically look somewhat different from a hand-generated model because the reactions and other structures will not normally correspond to the typical biological entities that we think of as reactions. A model will look something like this:

\begin{Verbatim}[frame=single]
     $ASSIGNMENTS
      V1 = # a list of expressions for assignment rules in the SBML
      V2 = # 
      ...
      K1 = # a list of expressions representing a kinetic laws in the SBML
      K2 = # ...
      ...
     $REACTIONS
      [X -> NIL, using["K1/V"]] # a list of reactions, one for each species 
      [NIL->Y, using["K2/V"]]   # in each SBML reaction
      ...
      [NIL -> U, using["expression"]] # a list of reactions, one for each 
      ...                             # rate rule in the SBML
     $RATES
      ...
     $IC
      ...
     $FROZEN
      ...
     $
\end{Verbatim}

Since some of the structures need to be translated, and the way things are evaluated may not correspond to the expected rules of SBML evaluation, as described in the following paragraphs.


\begin{enumerate}
\item All variables that have either their {\tt boundaryCondition} or {\tt constant} flag set to {\tt True} are converted to {\tt Frozen} variables in the model. This means that they may be set by {\tt using} reactions or by {\tt assignment} statements. Either of these could potentially conflict with the intent of the SBML model. For example, if the {\tt constant} field is set to {\tt True}, SBML says that such variables should never change, but if either a rate or assignment rule is present in the SBML model it will be used in the {\tt pycellerator} model (technically this would be an invalid SBML model, so should  not lead to problems). However, if both values are set to {\tt False} and the variable is set in both a rule and a reaction, then there could be a combination of assignments and ODES for that variable, in conflict with the intent of the SBML (again this would be invalid SBML, so the situation should not arise). 
\item If a {\tt parameter} is a {\tt variable} in an {\tt assignmentRule} and has a {\tt value} in a {\tt parameter} statement, then the {\tt value} in the {\tt parameter} statement will take precedence and the {\tt assignmentRule} will be ignored. 
\item All {\tt rateRules} are converted to {\tt "using"} reactions of the form {\tt Nil -> Variable} and the {\tt variable} is added to the list of {\tt frozen} variables, so that it cannot be changed by any other reactions. 
\item All reaction {\tt kineticLaws} are assigned to {\tt assignment} statements with the same variable as the reaction {\tt id}. 
\item Each {\tt reaction} is converted to a collection of {\tt using} creation and annihilation reactions, with one reaction for each species in the reaction. The reaction will always have the form of {\tt X -> Nil} or {\tt Nil -> X}, depending on the net stoichiometry of the species in the reaction. Thus, for example, if the SBML file has a reaction 
$$\TT{A + 3B -> 2A + B + C}$$ 
with a kinetic law {\tt K}, 
the following {\tt pycellerator} reactions will be generated:
\begin{align*}
&\TT{[Nil -> A, using["K/VA"]]}\\
&\TT{[B -> Nil, using["2*K/VB"]]}\\
&\TT{[Nil -> C, using["K/VC"]]}
\end{align*}
where {\tt VA}, {\tt VB}, and {\tt VC} are the volumes of the compartments that species {\tt A}, {\tt B} and {\tt C} reside in, respectively. All of the stoichiometries inside the {\tt using} expression are expressed as positive quantities because the sign will be calculated automatically by the interpreter module, because the reaction {\tt [X -> Nil, using["K"]]} will produce the same ODE term as {\tt [Nil -> X, using["-K"]]}, namely, ${\tt[X]}'=-{\tt K}$.

\item At each integration step, all {\tt assignmentRules} (with their parameter values instantiated) are evaluated before the differential equations are updated.  Thus a differential equation may refer to any variable defined by an {\tt assignmentRule}
\item All functions defined in the {\tt listOfFunctions} are instantiated globally so that any rule or reaction may refer to them. 


\end{enumerate}




\subsubsection{Syntax}

{\tt \$ python pyx.py sbml read -in \textit{filename} [-model \textit{filename}]}

If {\tt -model \textit{filename}} is specified, the output will be written to the specified file. Otherwise the output will be written to the file {\tt tmp.model}. Existing files will not be overwritten, and an approximation to the requested name will be used if the file already exists. 

\subsection{Writing SBML Files}

Not all features of SBML are supported. Only reactions, initial conditions, and parameters are written to the SBML file. Functions and assignment rules are not written to SBML in the present version.

\subsubsection{Syntax}

{\tt \$ python pyx.py sbml write -in \textit{modelfile} [-out \textit{sbmlfile}]}
